/**
* @license Apache-2.0
*
* Copyright (c) 2021 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MAIN //

/**
* Executes one or more asynchronous functions in parallel.
*
* ## Notes
*
* -   Each element in the input array should be comprised as follows:
*
*     ```text
*     [ <function>, <arg1>, <arg2>, ... ]
*     ```
*
*     when invoked `<function>` will be provided the specified arguments and an additional callback which has two parameters:
*
*     -   **error**: error object.
*     -   **result**: function result.
*
* -   The second argument to this function should be a callback argument. The callback argument is invoked with two arguments:
*
*     -   **error**: error object.
*     -   **result**: results array where the first element is the result of the first provided function, the second element is the result of the second provided function, and so on and so forth.
*
* -   While execution does **not** cancel pending functions, the function returns immediately upon encountering an error in one of the provided functions.
*
* @private
* @param {ArrayArray} fcns - list of functions (and associated arguments) to execute
* @param {Callback} clbk - callback to invoke upon completion
* @returns {void}
*/
function parallel( fcns, clbk ) {
	var results;
	var total;
	var count;
	var args;
	var FLG;
	var f;
	var i;

	total = fcns.length;
	count = 0;

	results = [];
	for ( i = 0; i < total; i++ ) {
		results.push( null );
		f = fcns[ i ];
		args = f.slice( 1 );
		args.push( callback( i ) );
		f[ 0 ].apply( null, args );
	}

	/**
	* Returns a callback to invoke after function completion.
	*
	* @private
	* @param {NonNegativeInteger} idx - function index
	* @returns {Callback} callback function
	*/
	function callback( idx ) {
		return cb;

		/**
		* Callback invoked after function completion.
		*
		* @private
		* @param {(Error|null)} error - error object
		* @param {*} result - function result
		* @returns {void}
		*/
		function cb( error, result ) {
			if ( error ) {
				return done( error );
			}
			results[ idx ] = result;
			done();
		}
	}

	/**
	* Callback invoked after processing function results.
	*
	* @private
	* @param {(Error|null)} [error] - error object
	* @returns {void}
	*/
	function done( error ) {
		if ( FLG ) {
			// If we have already processed an error, ignore any future results...
			return;
		}
		if ( error ) {
			FLG = true;
			return clbk( error );
		}
		count += 1;
		if ( count >= total ) {
			clbk( null, results );
		}
	}
}


// EXPORTS //

module.exports = parallel;
