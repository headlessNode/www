<!-- lint disable maximum-heading-length -->
<h1 id="ndarray">ndarray</h1>
<blockquote>
<p>Multidimensional array constructor.</p>
</blockquote>
<!-- Section to include introductory text. Make sure to keep an empty line after the intro `section` element and another before the `/section` close. -->
<section class="intro">
</section>
<!-- /.intro -->
<!-- Package usage documentation. -->
<section class="usage">
<h2 id="usage">Usage</h2>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> ndarray = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/ndarray/ctor'</span> );
</code></pre>
<p><a name="main"></a></p>
<h4 id="ndarray-dtype-buffer-shape-strides-offset-order-options-">ndarray( dtype, buffer, shape, strides, offset, order[, options] )</h4>
<p>Returns an <code>ndarray</code> instance.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Specify the array configuration:</span>
<span class="hljs-keyword">var</span> buffer = [ <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span> ];
<span class="hljs-keyword">var</span> shape = [ <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ];
<span class="hljs-keyword">var</span> order = <span class="hljs-string">'row-major'</span>;
<span class="hljs-keyword">var</span> strides = [ <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ];
<span class="hljs-keyword">var</span> offset = <span class="hljs-number">0</span>;

<span class="hljs-comment">// Create a new ndarray:</span>
<span class="hljs-keyword">var</span> arr = ndarray( <span class="hljs-string">'generic'</span>, buffer, shape, strides, offset, order );
<span class="hljs-comment">// returns &#x3C;ndarray></span>
</code></pre>
<p>The constructor expects the following arguments:</p>
<ul>
<li><strong>dtype</strong>: underlying <a href="/docs/api/latest/@stdlib/ndarray/dtypes">data type</a>.</li>
<li><strong>buffer</strong>: data buffer.</li>
<li><strong>shape</strong>: array shape (dimensions).</li>
<li><strong>strides</strong>: array strides which are index offsets specifying how to access along corresponding dimensions.</li>
<li><strong>offset</strong>: index offset specifying the location of the first indexed element in the data buffer.</li>
<li><strong>order</strong>: array order, which is either <code>row-major</code> (C-style) or <code>column-major</code> (Fortran-style).</li>
</ul>
<p>The constructor accepts the following <code>options</code>:</p>
<ul>
<li><strong>mode</strong>: specifies how to handle indices which exceed array dimensions. Default: <code>'throw'</code>.</li>
<li><strong>submode</strong>: a mode array which specifies for each dimension how to handle subscripts which exceed array dimensions. If provided fewer modes than dimensions, the constructor recycles modes using modulo arithmetic. Default: <code>[ options.mode ]</code>.</li>
</ul>
<p>The constructor supports the following <code>modes</code>:</p>
<ul>
<li><strong>throw</strong>: specifies that an <code>ndarray</code> instance should throw an error when an index exceeds array dimensions.</li>
<li><strong>wrap</strong>: specifies that an <code>ndarray</code> instance should wrap around an index exceeding array dimensions using modulo arithmetic.</li>
<li><strong>clamp</strong>: specifies that an <code>ndarray</code> instance should set an index exceeding array dimensions to either <code>0</code> (minimum index) or the maximum index.</li>
</ul>
<p>By default, an <code>ndarray</code> instance <strong>throws</strong> when provided an index which exceeds array dimensions. To support alternative indexing behavior, set the <code>mode</code> option, which will affect all public methods for getting and setting array elements.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> opts = {
    <span class="hljs-string">'mode'</span>: <span class="hljs-string">'clamp'</span>
};

<span class="hljs-comment">// Specify the array configuration:</span>
<span class="hljs-keyword">var</span> buffer = [ <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span> ];
<span class="hljs-keyword">var</span> shape = [ <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ];
<span class="hljs-keyword">var</span> order = <span class="hljs-string">'row-major'</span>;
<span class="hljs-keyword">var</span> strides = [ <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ];
<span class="hljs-keyword">var</span> offset = <span class="hljs-number">0</span>;

<span class="hljs-comment">// Create a new ndarray:</span>
<span class="hljs-keyword">var</span> arr = ndarray( <span class="hljs-string">'generic'</span>, buffer, shape, strides, offset, order, opts );
<span class="hljs-comment">// returns &#x3C;ndarray></span>

<span class="hljs-comment">// Attempt to access an out-of-bounds linear index (clamped):</span>
<span class="hljs-keyword">var</span> v = arr.iget( <span class="hljs-number">10</span> );
<span class="hljs-comment">// returns 4.0</span>
</code></pre>
<p>By default, the <code>mode</code> option is applied to subscripts which exceed array dimensions. To specify behavior for each dimension, set the <code>submode</code> option.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> opts = {
    <span class="hljs-string">'submode'</span>: [ <span class="hljs-string">'wrap'</span>, <span class="hljs-string">'clamp'</span> ]
};

<span class="hljs-comment">// Specify the array configuration:</span>
<span class="hljs-keyword">var</span> buffer = [ <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">6.0</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">8.0</span> ];
<span class="hljs-keyword">var</span> shape = [ <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ];
<span class="hljs-keyword">var</span> order = <span class="hljs-string">'row-major'</span>;
<span class="hljs-keyword">var</span> strides = [ <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ];
<span class="hljs-keyword">var</span> offset = <span class="hljs-number">0</span>;

<span class="hljs-comment">// Create a new ndarray:</span>
<span class="hljs-keyword">var</span> arr = ndarray( <span class="hljs-string">'generic'</span>, buffer, shape, strides, offset, order, opts );
<span class="hljs-comment">// returns &#x3C;ndarray></span>

<span class="hljs-comment">// Attempt to access out-of-bounds subscripts:</span>
<span class="hljs-keyword">var</span> v = arr.get( -<span class="hljs-number">2</span>, <span class="hljs-number">10</span>, -<span class="hljs-number">1</span> ); <span class="hljs-comment">// linear index: 3</span>
<span class="hljs-comment">// returns 4.0</span>
</code></pre>
<hr>
<h3 id="properties">Properties</h3>
<p><a name="static-prop-name"></a></p>
<h4 id="ndarrayname">ndarray.name</h4>
<p>String value of the ndarray constructor name.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> str = ndarray.name;
<span class="hljs-comment">// returns 'ndarray'</span>
</code></pre>
<p><a name="prop-byte-length"></a></p>
<h4 id="ndarrayprototypebytelength">ndarray.prototype.byteLength</h4>
<p>Size (in bytes) of the array (if known).</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">Float64Array</span> = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/array/float64'</span> );

<span class="hljs-comment">// Specify the array configuration:</span>
<span class="hljs-keyword">var</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Float64Array</span>( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span> ] );
<span class="hljs-keyword">var</span> shape = [ <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ];
<span class="hljs-keyword">var</span> order = <span class="hljs-string">'row-major'</span>;
<span class="hljs-keyword">var</span> strides = [ <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ];
<span class="hljs-keyword">var</span> offset = <span class="hljs-number">0</span>;

<span class="hljs-comment">// Create a new ndarray:</span>
<span class="hljs-keyword">var</span> arr = ndarray( <span class="hljs-string">'float64'</span>, buffer, shape, strides, offset, order );

<span class="hljs-comment">// Get the byte length:</span>
<span class="hljs-keyword">var</span> nbytes = arr.byteLength;
<span class="hljs-comment">// returns 32</span>
</code></pre>
<p>If unable to determine the size of the array, the property value is <code>null</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Specify the array configuration:</span>
<span class="hljs-keyword">var</span> buffer = [ <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span> ];
<span class="hljs-keyword">var</span> shape = [ <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ];
<span class="hljs-keyword">var</span> order = <span class="hljs-string">'row-major'</span>;
<span class="hljs-keyword">var</span> strides = [ <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ];
<span class="hljs-keyword">var</span> offset = <span class="hljs-number">0</span>;

<span class="hljs-comment">// Create a new ndarray:</span>
<span class="hljs-keyword">var</span> arr = ndarray( <span class="hljs-string">'generic'</span>, buffer, shape, strides, offset, order );

<span class="hljs-comment">// Get the byte length:</span>
<span class="hljs-keyword">var</span> nbytes = arr.byteLength;
<span class="hljs-comment">// returns null</span>
</code></pre>
<p><a name="prop-bytes-per-element"></a></p>
<h4 id="ndarrayprototypebytes_per_element">ndarray.prototype.BYTES_PER_ELEMENT</h4>
<p>Size (in bytes) of each array element (if known).</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">Float32Array</span> = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/array/float32'</span> );

<span class="hljs-comment">// Specify the array configuration:</span>
<span class="hljs-keyword">var</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Float32Array</span>( [ <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span> ] );
<span class="hljs-keyword">var</span> shape = [ <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ];
<span class="hljs-keyword">var</span> order = <span class="hljs-string">'row-major'</span>;
<span class="hljs-keyword">var</span> strides = [ <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ];
<span class="hljs-keyword">var</span> offset = <span class="hljs-number">0</span>;

<span class="hljs-comment">// Create a new ndarray:</span>
<span class="hljs-keyword">var</span> arr = ndarray( <span class="hljs-string">'float32'</span>, buffer, shape, strides, offset, order );

<span class="hljs-comment">// Get the number of bytes per element:</span>
<span class="hljs-keyword">var</span> nbytes = arr.BYTES_PER_ELEMENT;
<span class="hljs-comment">// returns 4</span>
</code></pre>
<p>If size of each array element is unknown, the property value is <code>null</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Specify the array configuration:</span>
<span class="hljs-keyword">var</span> buffer = [ <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span> ];
<span class="hljs-keyword">var</span> shape = [ <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ];
<span class="hljs-keyword">var</span> order = <span class="hljs-string">'row-major'</span>;
<span class="hljs-keyword">var</span> strides = [ <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ];
<span class="hljs-keyword">var</span> offset = <span class="hljs-number">0</span>;

<span class="hljs-comment">// Create a new ndarray:</span>
<span class="hljs-keyword">var</span> arr = ndarray( <span class="hljs-string">'generic'</span>, buffer, shape, strides, offset, order );

<span class="hljs-comment">// Get the number of bytes per element:</span>
<span class="hljs-keyword">var</span> nbytes = arr.BYTES_PER_ELEMENT;
<span class="hljs-comment">// returns null</span>
</code></pre>
<p><a name="prop-data"></a></p>
<h4 id="ndarrayprototypedata">ndarray.prototype.data</h4>
<p>A reference to the underlying data buffer.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">Int8Array</span> = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/array/int8'</span> );

<span class="hljs-comment">// Specify the array configuration:</span>
<span class="hljs-keyword">var</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int8Array</span>( [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> ] );
<span class="hljs-keyword">var</span> shape = [ <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ];
<span class="hljs-keyword">var</span> order = <span class="hljs-string">'row-major'</span>;
<span class="hljs-keyword">var</span> strides = [ <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ];
<span class="hljs-keyword">var</span> offset = <span class="hljs-number">0</span>;

<span class="hljs-comment">// Create a new ndarray:</span>
<span class="hljs-keyword">var</span> arr = ndarray( <span class="hljs-string">'int8'</span>, buffer, shape, strides, offset, order );

<span class="hljs-comment">// Get the buffer reference:</span>
<span class="hljs-keyword">var</span> d = arr.data;
<span class="hljs-comment">// returns &#x3C;Int8Array>[ 1, 2, 3, 4 ]</span>

<span class="hljs-keyword">var</span> bool = ( d === buffer );
<span class="hljs-comment">// returns true</span>
</code></pre>
<p><a name="prop-dtype"></a></p>
<h4 id="ndarrayprototypedtype">ndarray.prototype.dtype</h4>
<p>Underlying <a href="/docs/api/latest/@stdlib/ndarray/dtypes">data type</a>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">Uint8Array</span> = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/array/uint8'</span> );

<span class="hljs-comment">// Specify the array configuration:</span>
<span class="hljs-keyword">var</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>( [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> ] );
<span class="hljs-keyword">var</span> shape = [ <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ];
<span class="hljs-keyword">var</span> order = <span class="hljs-string">'row-major'</span>;
<span class="hljs-keyword">var</span> strides = [ -<span class="hljs-number">2</span>, <span class="hljs-number">1</span> ];
<span class="hljs-keyword">var</span> offset = <span class="hljs-number">2</span>;

<span class="hljs-comment">// Create a new ndarray:</span>
<span class="hljs-keyword">var</span> arr = ndarray( <span class="hljs-string">'uint8'</span>, buffer, shape, strides, offset, order );

<span class="hljs-comment">// Get the underlying data type:</span>
<span class="hljs-keyword">var</span> dtype = arr.dtype;
<span class="hljs-comment">// returns 'uint8'</span>
</code></pre>
<p><a name="prop-flags"></a></p>
<h4 id="ndarrayprototypeflags">ndarray.prototype.flags</h4>
<p>Information regarding the memory layout of the array. The returned <code>object</code> has the following properties:</p>
<ul>
<li><strong>ROW_MAJOR_CONTIGUOUS</strong>: <code>boolean</code> indicating if an array is row-major contiguous.</li>
<li><strong>COLUMN_MAJOR_CONTIGUOUS</strong>: <code>boolean</code> indicating if an array is column-major contiguous.</li>
</ul>
<p>An array is contiguous if (1) an array is compatible with being stored in a single memory segment and (2) each array element is adjacent to the next array element. Note that an array can be both row-major contiguous and column-major contiguous at the same time (e.g., if an array is a 1-dimensional ndarray with <code>strides = [1]</code>).</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">Int32Array</span> = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/array/int32'</span> );

<span class="hljs-comment">// Specify the array configuration:</span>
<span class="hljs-keyword">var</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int32Array</span>( [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> ] );
<span class="hljs-keyword">var</span> shape = [ <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ];
<span class="hljs-keyword">var</span> order = <span class="hljs-string">'column-major'</span>;
<span class="hljs-keyword">var</span> strides = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span> ];
<span class="hljs-keyword">var</span> offset = <span class="hljs-number">0</span>;

<span class="hljs-comment">// Create a new ndarray:</span>
<span class="hljs-keyword">var</span> arr = ndarray( <span class="hljs-string">'int32'</span>, buffer, shape, strides, offset, order );

<span class="hljs-comment">// Get the array flags:</span>
<span class="hljs-keyword">var</span> flg = arr.flags;
<span class="hljs-comment">// returns {...}</span>
</code></pre>
<p><a name="prop-length"></a></p>
<h4 id="ndarrayprototypelength">ndarray.prototype.length</h4>
<p>Number of array elements.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">Uint16Array</span> = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/array/uint16'</span> );

<span class="hljs-comment">// Specify the array configuration:</span>
<span class="hljs-keyword">var</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint16Array</span>( [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> ] );
<span class="hljs-keyword">var</span> shape = [ <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ];
<span class="hljs-keyword">var</span> order = <span class="hljs-string">'column-major'</span>;
<span class="hljs-keyword">var</span> strides = [ -<span class="hljs-number">1</span>, -<span class="hljs-number">2</span> ];
<span class="hljs-keyword">var</span> offset = <span class="hljs-number">3</span>;

<span class="hljs-comment">// Create a new ndarray:</span>
<span class="hljs-keyword">var</span> arr = ndarray( <span class="hljs-string">'uint16'</span>, buffer, shape, strides, offset, order );

<span class="hljs-comment">// Get the array length:</span>
<span class="hljs-keyword">var</span> len = arr.length;
<span class="hljs-comment">// returns 4</span>
</code></pre>
<p><a name="prop-ndims"></a></p>
<h4 id="ndarrayprototypendims">ndarray.prototype.ndims</h4>
<p>Number of dimensions.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">Uint8ClampedArray</span> = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/array/uint8c'</span> );

<span class="hljs-comment">// Specify the array configuration:</span>
<span class="hljs-keyword">var</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8ClampedArray</span>( [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> ] );
<span class="hljs-keyword">var</span> shape = [ <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ];
<span class="hljs-keyword">var</span> order = <span class="hljs-string">'row-major'</span>;
<span class="hljs-keyword">var</span> strides = [ -<span class="hljs-number">2</span>, -<span class="hljs-number">1</span> ];
<span class="hljs-keyword">var</span> offset = <span class="hljs-number">3</span>;

<span class="hljs-comment">// Create a new ndarray:</span>
<span class="hljs-keyword">var</span> arr = ndarray( <span class="hljs-string">'uint8c'</span>, buffer, shape, strides, offset, order );

<span class="hljs-comment">// Get the number of dimensions:</span>
<span class="hljs-keyword">var</span> ndims = arr.ndims;
<span class="hljs-comment">// returns 2</span>
</code></pre>
<p><a name="prop-offset"></a></p>
<h4 id="ndarrayprototypeoffset">ndarray.prototype.offset</h4>
<p>Index offset which specifies the <code>buffer</code> index at which to start iterating over array elements.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">Int16Array</span> = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/array/int16'</span> );

<span class="hljs-comment">// Specify the array configuration:</span>
<span class="hljs-keyword">var</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int16Array</span>( [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span> ] );
<span class="hljs-keyword">var</span> shape = [ <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ];
<span class="hljs-keyword">var</span> order = <span class="hljs-string">'row-major'</span>;
<span class="hljs-keyword">var</span> strides = [ -<span class="hljs-number">2</span>, -<span class="hljs-number">1</span> ];
<span class="hljs-keyword">var</span> offset = <span class="hljs-number">10</span>;

<span class="hljs-comment">// Create a new ndarray:</span>
<span class="hljs-keyword">var</span> arr = ndarray( <span class="hljs-string">'int16'</span>, buffer, shape, strides, offset, order );

<span class="hljs-comment">// Get the index offset:</span>
<span class="hljs-keyword">var</span> o = arr.offset;
<span class="hljs-comment">// returns 10</span>
</code></pre>
<p><a name="prop-order"></a></p>
<h4 id="ndarrayprototypeorder">ndarray.prototype.order</h4>
<p>Array order. The array order is either row-major (C-style) or column-major (Fortran-style).</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">Uint32Array</span> = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/array/uint32'</span> );

<span class="hljs-comment">// Specify the array configuration:</span>
<span class="hljs-keyword">var</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint32Array</span>( [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> ] );
<span class="hljs-keyword">var</span> shape = [ <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ];
<span class="hljs-keyword">var</span> order = <span class="hljs-string">'row-major'</span>;
<span class="hljs-keyword">var</span> strides = [ <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ];
<span class="hljs-keyword">var</span> offset = <span class="hljs-number">0</span>;

<span class="hljs-comment">// Create a new ndarray:</span>
<span class="hljs-keyword">var</span> arr = ndarray( <span class="hljs-string">'uint32'</span>, buffer, shape, strides, offset, order );

<span class="hljs-comment">// Get the array order:</span>
<span class="hljs-keyword">var</span> ord = arr.order;
<span class="hljs-comment">// returns 'row-major'</span>
</code></pre>
<p><a name="prop-shape"></a></p>
<h4 id="ndarrayprototypeshape">ndarray.prototype.shape</h4>
<p>Returns a copy of the array shape.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Specify the array configuration:</span>
<span class="hljs-keyword">var</span> buffer = [ <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">6.0</span> ];
<span class="hljs-keyword">var</span> shape = [ <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ];
<span class="hljs-keyword">var</span> order = <span class="hljs-string">'row-major'</span>;
<span class="hljs-keyword">var</span> strides = [ <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ];
<span class="hljs-keyword">var</span> offset = <span class="hljs-number">2</span>;

<span class="hljs-comment">// Create a new ndarray:</span>
<span class="hljs-keyword">var</span> arr = ndarray( <span class="hljs-string">'generic'</span>, buffer, shape, strides, offset, order );

<span class="hljs-comment">// Get the array shape:</span>
<span class="hljs-keyword">var</span> dims = arr.shape;
<span class="hljs-comment">// returns [ 2, 2 ]</span>
</code></pre>
<p><a name="prop-strides"></a></p>
<h4 id="ndarrayprototypestrides">ndarray.prototype.strides</h4>
<p>Returns a copy of the array strides which specify how to access data along corresponding array dimensions.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Specify the array configuration:</span>
<span class="hljs-keyword">var</span> buffer = [ <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span> ];
<span class="hljs-keyword">var</span> shape = [ <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ];
<span class="hljs-keyword">var</span> order = <span class="hljs-string">'column-major'</span>;
<span class="hljs-keyword">var</span> strides = [ -<span class="hljs-number">1</span>, <span class="hljs-number">2</span> ];
<span class="hljs-keyword">var</span> offset = <span class="hljs-number">1</span>;

<span class="hljs-comment">// Create a new ndarray:</span>
<span class="hljs-keyword">var</span> arr = ndarray( <span class="hljs-string">'generic'</span>, buffer, shape, strides, offset, order );

<span class="hljs-comment">// Get the array strides:</span>
<span class="hljs-keyword">var</span> s = arr.strides;
<span class="hljs-comment">// returns [ -1, 2 ]</span>
</code></pre>
<hr>
<h3 id="methods">Methods</h3>
<p><a name="method-get"></a></p>
<h4 id="ndarrayprototypeget-i-j-k--">ndarray.prototype.get( i, j, k, ... )</h4>
<p>Returns an array element specified according to provided subscripts. The number of provided subscripts must <strong>equal</strong> the number of dimensions.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Specify the array configuration:</span>
<span class="hljs-keyword">var</span> buffer = [ <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">6.0</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">8.0</span> ];
<span class="hljs-keyword">var</span> shape = [ <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ];
<span class="hljs-keyword">var</span> order = <span class="hljs-string">'row-major'</span>;
<span class="hljs-keyword">var</span> strides = [ <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ];
<span class="hljs-keyword">var</span> offset = <span class="hljs-number">2</span>;

<span class="hljs-comment">// Create a new ndarray:</span>
<span class="hljs-keyword">var</span> arr = ndarray( <span class="hljs-string">'generic'</span>, buffer, shape, strides, offset, order );

<span class="hljs-comment">// Get the element located at (1,1):</span>
<span class="hljs-keyword">var</span> v = arr.get( <span class="hljs-number">1</span>, <span class="hljs-number">1</span> );
<span class="hljs-comment">// returns 6.0</span>
</code></pre>
<p><a name="method-iget"></a></p>
<h4 id="ndarrayprototypeiget-idx-">ndarray.prototype.iget( idx )</h4>
<p>Returns an array element located at a specified linear index.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Specify the array configuration:</span>
<span class="hljs-keyword">var</span> buffer = [ <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">6.0</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">8.0</span> ];
<span class="hljs-keyword">var</span> shape = [ <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ];
<span class="hljs-keyword">var</span> order = <span class="hljs-string">'row-major'</span>;
<span class="hljs-keyword">var</span> strides = [ <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ];
<span class="hljs-keyword">var</span> offset = <span class="hljs-number">2</span>;

<span class="hljs-comment">// Create a new ndarray:</span>
<span class="hljs-keyword">var</span> arr = ndarray( <span class="hljs-string">'generic'</span>, buffer, shape, strides, offset, order );

<span class="hljs-comment">// Get the element located at index 3:</span>
<span class="hljs-keyword">var</span> v = arr.iget( <span class="hljs-number">3</span> );
<span class="hljs-comment">// returns 6.0</span>
</code></pre>
<p>For zero-dimensional arrays, the input argument is ignored and, for clarity, should <strong>not</strong> be provided.</p>
<p><a name="method-set"></a></p>
<h4 id="ndarrayprototypeset-i-j-k--v-">ndarray.prototype.set( i, j, k, ..., v )</h4>
<p>Sets an array element specified according to provided subscripts. The number of provided subscripts must <strong>equal</strong> the number of dimensions.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Specify the array configuration:</span>
<span class="hljs-keyword">var</span> buffer = [ <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span> ];
<span class="hljs-keyword">var</span> shape = [ <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ];
<span class="hljs-keyword">var</span> order = <span class="hljs-string">'row-major'</span>;
<span class="hljs-keyword">var</span> strides = [ <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ];
<span class="hljs-keyword">var</span> offset = <span class="hljs-number">0</span>;

<span class="hljs-comment">// Create a new ndarray:</span>
<span class="hljs-keyword">var</span> arr = ndarray( <span class="hljs-string">'generic'</span>, buffer, shape, strides, offset, order );

<span class="hljs-comment">// Set the element located at (1,1):</span>
arr.set( <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">40.0</span> );
<span class="hljs-keyword">var</span> v = arr.get( <span class="hljs-number">1</span>, <span class="hljs-number">1</span> );
<span class="hljs-comment">// returns 40.0</span>

<span class="hljs-comment">// Get the underlying buffer:</span>
<span class="hljs-keyword">var</span> d = arr.data;
<span class="hljs-comment">// returns [ 1.0, 2.0, 3.0, 40.0 ]</span>
</code></pre>
<p>The method returns the <code>ndarray</code> instance.</p>
<p><a name="method-iset"></a></p>
<h4 id="ndarrayprototypeiset-idx-v-">ndarray.prototype.iset( idx, v )</h4>
<p>Sets an array element located at a specified linear index.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Specify the array configuration:</span>
<span class="hljs-keyword">var</span> buffer = [ <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span> ];
<span class="hljs-keyword">var</span> shape = [ <span class="hljs-number">2</span>, <span class="hljs-number">2</span> ];
<span class="hljs-keyword">var</span> order = <span class="hljs-string">'row-major'</span>;
<span class="hljs-keyword">var</span> strides = [ <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ];
<span class="hljs-keyword">var</span> offset = <span class="hljs-number">0</span>;

<span class="hljs-comment">// Create a new ndarray:</span>
<span class="hljs-keyword">var</span> arr = ndarray( <span class="hljs-string">'generic'</span>, buffer, shape, strides, offset, order );

<span class="hljs-comment">// Set the element located at index 3:</span>
arr.iset( <span class="hljs-number">3</span>, <span class="hljs-number">40.0</span> );
<span class="hljs-keyword">var</span> v = arr.iget( <span class="hljs-number">3</span> );
<span class="hljs-comment">// returns 40.0</span>

<span class="hljs-comment">// Get the underlying buffer:</span>
<span class="hljs-keyword">var</span> d = arr.data;
<span class="hljs-comment">// returns [ 1.0, 2.0, 3.0, 40.0 ]</span>
</code></pre>
<p>For zero-dimensional arrays, the first, and <strong>only</strong>, argument should be the value <code>v</code> to set. The method returns the <code>ndarray</code> instance.</p>
<p><a name="method-to-string"></a></p>
<h4 id="ndarrayprototypetostring">ndarray.prototype.toString()</h4>
<p>Serializes an <code>ndarray</code> as a <code>string</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Specify the array configuration:</span>
<span class="hljs-keyword">var</span> buffer = [ <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">6.0</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">8.0</span> ];
<span class="hljs-keyword">var</span> shape = [ <span class="hljs-number">3</span>, <span class="hljs-number">2</span> ];
<span class="hljs-keyword">var</span> order = <span class="hljs-string">'row-major'</span>;
<span class="hljs-keyword">var</span> strides = [ <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ];
<span class="hljs-keyword">var</span> offset = <span class="hljs-number">2</span>;

<span class="hljs-comment">// Create a new ndarray:</span>
<span class="hljs-keyword">var</span> arr = ndarray( <span class="hljs-string">'generic'</span>, buffer, shape, strides, offset, order );

<span class="hljs-comment">// Serialize to a string:</span>
<span class="hljs-keyword">var</span> str = arr.toString();
<span class="hljs-comment">// returns "ndarray( 'generic', [ 3, 4, 5, 6, 7, 8 ], [ 3, 2 ], [ 2, 1 ], 0, 'row-major' )"</span>
</code></pre>
<p>The method does <strong>not</strong> serialize data outside of the buffer region defined by the array configuration.</p>
<p><a name="method-to-json"></a></p>
<h4 id="ndarrayprototypetojson">ndarray.prototype.toJSON()</h4>
<p>Serializes an <code>ndarray</code> as a <a href="http://www.json.org/">JSON</a> <code>object</code>. <code>JSON.stringify()</code> implicitly calls this method when stringifying an <code>ndarray</code> instance.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Specify the array configuration:</span>
<span class="hljs-keyword">var</span> buffer = [ <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">6.0</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">8.0</span> ];
<span class="hljs-keyword">var</span> shape = [ <span class="hljs-number">3</span>, <span class="hljs-number">2</span> ];
<span class="hljs-keyword">var</span> order = <span class="hljs-string">'row-major'</span>;
<span class="hljs-keyword">var</span> strides = [ <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ];
<span class="hljs-keyword">var</span> offset = <span class="hljs-number">2</span>;

<span class="hljs-comment">// Create a new ndarray:</span>
<span class="hljs-keyword">var</span> arr = ndarray( <span class="hljs-string">'generic'</span>, buffer, shape, strides, offset, order );

<span class="hljs-comment">// Serialize to JSON:</span>
<span class="hljs-keyword">var</span> o = arr.toJSON();
<span class="hljs-comment">// returns { 'type': 'ndarray', 'dtype': 'generic', 'flags': {...}, 'offset': 0, 'order': 'row-major', 'shape': [ 3, 2 ], 'strides': [ 2, 1 ], 'data': [ 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] }</span>
</code></pre>
<p>The method does <strong>not</strong> serialize data outside of the buffer region defined by the array configuration.</p>
</section>
<!-- /.usage -->
<!-- Package usage notes. Make sure to keep an empty line after the `section` element and another before the `/section` close. -->
<section class="notes">
<h2 id="notes">Notes</h2>
<ul>
<li>
<p>To create a zero-dimensional array, provide an empty <code>shape</code> and a single <code>strides</code> element equal to <code>0</code>. The <code>order</code> can be either <code>row-major</code> or <code>column-major</code> and has no effect on data storage or access.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> buffer = [ <span class="hljs-number">1</span> ];
<span class="hljs-keyword">var</span> shape = [];
<span class="hljs-keyword">var</span> order = <span class="hljs-string">'row-major'</span>;
<span class="hljs-keyword">var</span> strides = [ <span class="hljs-number">0</span> ];
<span class="hljs-keyword">var</span> offset = <span class="hljs-number">0</span>;

<span class="hljs-comment">// Create a new zero-dimensional array:</span>
<span class="hljs-keyword">var</span> arr = ndarray( <span class="hljs-string">'generic'</span>, buffer, shape, strides, offset, order );
<span class="hljs-comment">// returns &#x3C;ndarray></span>
</code></pre>
</li>
</ul>
</section>
<!-- /.notes -->
<!-- Package usage examples. -->
<section class="examples">
<hr>
<h2 id="examples">Examples</h2>
<!-- eslint no-undef: "error" -->
<pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">Float32Array</span> = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/array/float32'</span> );
<span class="hljs-keyword">var</span> ndarray = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/ndarray/ctor'</span> );

<span class="hljs-comment">// Create a data buffer:</span>
<span class="hljs-keyword">var</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Float32Array</span>( (<span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span>) + <span class="hljs-number">100</span> );

<span class="hljs-comment">// Specify the array shape:</span>
<span class="hljs-keyword">var</span> shape = [ <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span> ];

<span class="hljs-comment">// Specify the array strides:</span>
<span class="hljs-keyword">var</span> strides = [ <span class="hljs-number">27</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span> ];

<span class="hljs-comment">// Specify the index offset:</span>
<span class="hljs-keyword">var</span> offset = <span class="hljs-number">4</span>;

<span class="hljs-comment">// Specify the order:</span>
<span class="hljs-keyword">var</span> order = <span class="hljs-string">'row-major'</span>; <span class="hljs-comment">// C-style</span>

<span class="hljs-comment">// Create a new ndarray:</span>
<span class="hljs-keyword">var</span> arr = ndarray( <span class="hljs-string">'float32'</span>, buffer, shape, strides, offset, order );

<span class="hljs-comment">// Retrieve an array value:</span>
<span class="hljs-keyword">var</span> v = arr.get( <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> );
<span class="hljs-comment">// returns 0.0</span>

<span class="hljs-comment">// Set an array value:</span>
arr.set( <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10.0</span> );

<span class="hljs-comment">// Retrieve the array value:</span>
v = arr.get( <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> );
<span class="hljs-comment">// returns 10.0</span>

<span class="hljs-comment">// Serialize the array as a string:</span>
<span class="hljs-keyword">var</span> str = arr.toString();
<span class="hljs-comment">// returns "ndarray( 'float32', new Float32Array( [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] ), [ 3, 3, 3, 3 ], [ 27, 9, 3, 1 ], 0, 'row-major' )"</span>

<span class="hljs-comment">// Serialize the array as JSON:</span>
str = <span class="hljs-built_in">JSON</span>.stringify( arr.toJSON() );
<span class="hljs-comment">// returns '{"type":"ndarray","dtype":"float32","flags":{},"order":"row-major","shape":[3,3,3,3],"strides":[27,9,3,1],"data":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}'</span>
</code></pre>
</section>
<!-- /.examples -->
<!-- C interface documentation. -->
<hr>
<section class="c">
<h2 id="c-apis">C APIs</h2>
<!-- Section to include introductory text. Make sure to keep an empty line after the intro `section` element and another before the `/section` close. -->
<section class="intro">
</section>
<!-- /.intro -->
<!-- C usage documentation. -->
<section class="usage">
<h3 id="usage-1">Usage</h3>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/ctor.h"</span></span>
</code></pre>
<h4 id="ndarray-1">ndarray</h4>
<p>Structure holding ndarray data.</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/dtypes.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/index_modes.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/orders.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/base/bytes_per_element.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdint.h></span></span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ndarray</span> {</span>
    <span class="hljs-comment">// Underlying data type:</span>
    <span class="hljs-keyword">int16_t</span> dtype;

    <span class="hljs-comment">// Pointer to the underlying byte array:</span>
    <span class="hljs-keyword">uint8_t</span> *data;

    <span class="hljs-comment">// Number of array dimensions:</span>
    <span class="hljs-keyword">int64_t</span> ndims;

    <span class="hljs-comment">// Array shape (dimensions):</span>
    <span class="hljs-keyword">int64_t</span> *shape;

    <span class="hljs-comment">// Array strides (in bytes) specifying how to iterate over a strided array:</span>
    <span class="hljs-keyword">int64_t</span> *strides;

    <span class="hljs-comment">// Byte offset which specifies the location at which to start iterating over array elements:</span>
    <span class="hljs-keyword">int64_t</span> offset;

    <span class="hljs-comment">// Array order (either row-major (C-style) or column-major (Fortran-style)):</span>
    <span class="hljs-keyword">int8_t</span> order;

    <span class="hljs-comment">// Mode specifying how to handle indices which exceed array dimensions:</span>
    <span class="hljs-keyword">int8_t</span> imode;

    <span class="hljs-comment">// Number of subscript modes:</span>
    <span class="hljs-keyword">int64_t</span> nsubmodes;

    <span class="hljs-comment">// Mode(s) specifying how to handle subscripts which exceed array dimensions on a per dimension basis:</span>
    <span class="hljs-keyword">int8_t</span> *submodes;

    <span class="hljs-comment">// Number of array elements:</span>
    <span class="hljs-keyword">int64_t</span> length;

    <span class="hljs-comment">// Size in bytes:</span>
    <span class="hljs-keyword">int64_t</span> byteLength;

    <span class="hljs-comment">// Number of bytes per element (i.e., item size):</span>
    <span class="hljs-keyword">int64_t</span> BYTES_PER_ELEMENT;

    <span class="hljs-comment">// Bit mask providing information regarding the memory layout of the array (e.g., see macros):</span>
    <span class="hljs-keyword">int64_t</span> flags;
};
</code></pre>
<h4 id="stdlib_ndarray_row_major_contiguous_flag">STDLIB_NDARRAY_ROW_MAJOR_CONTIGUOUS_FLAG</h4>
<p>Macro defining a flag indicating whether an ndarray is row-major (C-style) contiguous.</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STDLIB_NDARRAY_ROW_MAJOR_CONTIGUOUS_FLAG 0x0001</span>
</code></pre>
<p>Notes:</p>
<ul>
<li>Row-major order indicates that the last ndarray index varies the fastest.</li>
<li>Contiguous means that an ndarray is compatible with being stored in a single memory segment and that ndarray elements are adjacent to each other in memory.</li>
<li><code>strides</code> array is in reverse order to that of column-major order.</li>
<li>An ndarray can be both row-major and column-major contiguous (e.g., if an ndarray is one-dimensional).</li>
</ul>
<h4 id="stdlib_ndarray_column_major_contiguous_flag">STDLIB_NDARRAY_COLUMN_MAJOR_CONTIGUOUS_FLAG</h4>
<p>Macro defining a flag indicating whether an ndarray is column-major (Fortran-style) contiguous.</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> STDLIB_NDARRAY_COLUMN_MAJOR_CONTIGUOUS_FLAG 0x0002</span>
</code></pre>
<p>Notes:</p>
<ul>
<li>Column-major order indicates that the first ndarray index varies the fastest.</li>
<li>Contiguous means that an ndarray is compatible with being stored in a single memory segment and that ndarray elements are adjacent to each other in memory.</li>
<li><code>strides</code> array is in reverse order to that of row-major order.</li>
<li>An ndarray can be both row-major and column-major contiguous (e.g., if an ndarray is one-dimensional).</li>
</ul>
<hr>
<!-- NOTE: keep functions in alphabetical order -->
<h4 id="stdlib_ndarray_allocate-dtype-data-ndims-shape-strides-offset-order-imode-nsubmodes-submodes-">stdlib_ndarray_allocate( dtype, *data, ndims, *shape, *strides, offset, order, imode, nsubmodes, *submodes )</h4>
<p>Returns a pointer to a dynamically allocated ndarray.</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/ctor.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/dtypes.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/index_modes.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/orders.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/base/bytes_per_element.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdlib.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdio.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdint.h></span></span>

<span class="hljs-comment">// Specify the underlying data type:</span>
<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">STDLIB_NDARRAY_DTYPE</span> <span class="hljs-title">dtype</span> =</span> STDLIB_NDARRAY_FLOAT64;

<span class="hljs-comment">// Create an underlying byte array:</span>
<span class="hljs-keyword">uint8_t</span> buffer[] = { <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> };

<span class="hljs-comment">// Specify the number of array dimensions:</span>
<span class="hljs-keyword">int64_t</span> ndims = <span class="hljs-number">1</span>;

<span class="hljs-comment">// Specify the array shape:</span>
<span class="hljs-keyword">int64_t</span> shape[] = { <span class="hljs-number">3</span> }; <span class="hljs-comment">// vector consisting of 3 doubles</span>

<span class="hljs-comment">// Specify the array strides:</span>
<span class="hljs-keyword">int64_t</span> strides[] = { STDLIB_NDARRAY_FLOAT64_BYTES_PER_ELEMENT };

<span class="hljs-comment">// Specify the byte offset:</span>
<span class="hljs-keyword">int64_t</span> offset = <span class="hljs-number">0</span>;

<span class="hljs-comment">// Specify the array order (note: this does not matter for a 1-dimensional array):</span>
<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">STDLIB_NDARRAY_ORDER</span> <span class="hljs-title">order</span> =</span> STDLIB_NDARRAY_ROW_MAJOR;

<span class="hljs-comment">// Specify the index mode:</span>
<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">STDLIB_NDARRAY_INDEX_MODE</span> <span class="hljs-title">imode</span> =</span> STDLIB_NDARRAY_INDEX_ERROR;

<span class="hljs-comment">// Specify the subscript index modes:</span>
<span class="hljs-keyword">int8_t</span> submodes[] = { STDLIB_NDARRAY_INDEX_ERROR };
<span class="hljs-keyword">int64_t</span> nsubmodes = <span class="hljs-number">1</span>;

<span class="hljs-comment">// Create an ndarray:</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ndarray</span> *<span class="hljs-title">x</span> =</span> stdlib_ndarray_allocate( dtype, buffer, ndims, shape, strides, offset, order, imode, nsubmodes, submodes );
<span class="hljs-keyword">if</span> ( x == <span class="hljs-literal">NULL</span> ) {
    <span class="hljs-built_in">fprintf</span>( <span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error allocating memory.\n"</span> );
    <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
}

<span class="hljs-comment">// Free allocated memory:</span>
stdlib_ndarray_free( x );
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>dtype</strong>: <code>[in] int16_t</code> <a href="/docs/api/latest/@stdlib/ndarray/dtypes">data type</a>.</li>
<li><strong>data</strong>: <code>[in] uint8_t*</code> pointer to the underlying byte array.</li>
<li><strong>ndims</strong>: <code>[in] int64_t</code> number of dimensions.</li>
<li><strong>shape</strong>: <code>[in] int64_t*</code> array shape (i.e., dimensions).</li>
<li><strong>strides</strong>: <code>[in] int64_t*</code> array strides (in bytes).</li>
<li><strong>offset</strong>: <code>[in] int64_t</code> byte offset specifying the location of the first element.</li>
<li><strong>order</strong>: <code>[in] int8_t</code> specifies whether an array is <a href="/docs/api/latest/@stdlib/ndarray/orders">row-major</a> (C-style) or <a href="/docs/api/latest/@stdlib/ndarray/orders">column-major</a> (Fortran-style).</li>
<li><strong>imode</strong>: <code>[in] int8_t</code> specifies the <a href="/docs/api/latest/@stdlib/ndarray/index-modes">index mode</a> (i.e., how to handle indices which exceed array dimensions).</li>
<li><strong>nsubmodes</strong>: <code>[in] int64_t</code> number of subscript modes.</li>
<li><strong>submodes</strong>: <code>[in] int8_t*</code> specifies how to handle subscripts which <a href="/docs/api/latest/@stdlib/ndarray/index-modes">exceed</a> array dimensions on a per dimension basis (if provided fewer submodes than dimensions, submodes are recycled using modulo arithmetic).</li>
</ul>
<pre><code class="hljs language-c"><span class="hljs-function">struct ndarray * <span class="hljs-title">stdlib_ndarray_allocate</span><span class="hljs-params">( <span class="hljs-keyword">int16_t</span> dtype, <span class="hljs-keyword">uint8_t</span> *data, <span class="hljs-keyword">int64_t</span> ndims, <span class="hljs-keyword">int64_t</span> *shape, <span class="hljs-keyword">int64_t</span> *strides, <span class="hljs-keyword">int64_t</span> offset, <span class="hljs-keyword">int8_t</span> order, <span class="hljs-keyword">int8_t</span> imode, <span class="hljs-keyword">int64_t</span> nsubmodes, <span class="hljs-keyword">int8_t</span> *submodes )</span></span>;
</code></pre>
<p>Notes:</p>
<ul>
<li>The user is responsible for freeing the allocated memory.</li>
</ul>
<h4 id="stdlib_ndarray_bytelength-arr-">stdlib_ndarray_bytelength( *arr )</h4>
<p>Returns the size of an ndarray (in bytes).</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/ctor.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdint.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdlib.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdio.h></span></span>

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Create an ndarray:</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ndarray</span> *<span class="hljs-title">x</span> =</span> stdlib_ndarray_allocate( ... );
<span class="hljs-keyword">if</span> ( x == <span class="hljs-literal">NULL</span> ) {
    <span class="hljs-built_in">fprintf</span>( <span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error allocating memory.\n"</span> );
    <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
}

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Retrieve the ndarray size:</span>
<span class="hljs-keyword">int64_t</span> N = stdlib_ndarray_bytelength( x );

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Free allocated memory:</span>
stdlib_ndarray_free( x );
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
</ul>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">stdlib_ndarray_bytelength</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr )</span></span>;
</code></pre>
<h4 id="stdlib_ndarray_data-arr-">stdlib_ndarray_data( *arr )</h4>
<p>Returns a pointer to an ndarray's underlying byte array.</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/ctor.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdint.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdlib.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdio.h></span></span>

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Create an ndarray:</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ndarray</span> *<span class="hljs-title">x</span> =</span> stdlib_ndarray_allocate( ... );
<span class="hljs-keyword">if</span> ( x == <span class="hljs-literal">NULL</span> ) {
    <span class="hljs-built_in">fprintf</span>( <span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error allocating memory.\n"</span> );
    <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
}

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Retrieve the underlying byte array:</span>
<span class="hljs-keyword">uint8_t</span> *data = stdlib_ndarray_data( x );

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Free allocated memory:</span>
stdlib_ndarray_free( x );
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
</ul>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">uint8_t</span> * <span class="hljs-title">stdlib_ndarray_data</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr )</span></span>;
</code></pre>
<h4 id="stdlib_ndarray_dimension-arr-i-">stdlib_ndarray_dimension( *arr, i )</h4>
<p>Returns an ndarray dimension.</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/ctor.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdint.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdlib.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdio.h></span></span>

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Create an ndarray:</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ndarray</span> *<span class="hljs-title">x</span> =</span> stdlib_ndarray_allocate( ... );
<span class="hljs-keyword">if</span> ( x == <span class="hljs-literal">NULL</span> ) {
    <span class="hljs-built_in">fprintf</span>( <span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error allocating memory.\n"</span> );
    <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
}

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Retrieve a dimension:</span>
<span class="hljs-keyword">int64_t</span> dim = stdlib_ndarray_dimension( x, <span class="hljs-number">0</span> );

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Free allocated memory:</span>
stdlib_ndarray_free( x );
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>i</strong>: <code>[in] int64_t</code> dimension index.</li>
</ul>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">stdlib_ndarray_dimension</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> i )</span></span>;
</code></pre>
<p>Notes:</p>
<ul>
<li>The function does perform bounds checking for the dimension index.</li>
</ul>
<h4 id="stdlib_ndarray_disable_flags-arr-flags-">stdlib_ndarray_disable_flags( *arr, flags )</h4>
<p>Disables specified ndarray flags.</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/ctor.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdint.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdlib.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdio.h></span></span>

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Create an ndarray:</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ndarray</span> *<span class="hljs-title">x</span> =</span> stdlib_ndarray_allocate( ... );
<span class="hljs-keyword">if</span> ( x == <span class="hljs-literal">NULL</span> ) {
    <span class="hljs-built_in">fprintf</span>( <span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error allocating memory.\n"</span> );
    <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
}

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Disables specified ndarray flags:</span>
<span class="hljs-keyword">int8_t</span> status = stdlib_ndarray_disable_flags( x, STDLIB_NDARRAY_ROW_MAJOR_CONTIGUOUS_FLAG );

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Free allocated memory:</span>
stdlib_ndarray_free( x );
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>flags</strong>: <code>[in] int64_t</code> bit mask to disable flags.</li>
</ul>
<p>The function returns a status code of <code>0</code> if able to successfully disable flags.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_disable_flags</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> flags )</span></span>;
</code></pre>
<p>Notes:</p>
<ul>
<li>The function does not perform any sanity checks and <strong>assumes</strong> the user knows what s/he is doing.</li>
</ul>
<h4 id="stdlib_ndarray_dtype-arr-">stdlib_ndarray_dtype( *arr )</h4>
<p>Returns the data type of an ndarray.</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/ctor.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/dtypes.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdlib.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdio.h></span></span>

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Create an ndarray:</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ndarray</span> *<span class="hljs-title">x</span> =</span> stdlib_ndarray_allocate( ... );
<span class="hljs-keyword">if</span> ( x == <span class="hljs-literal">NULL</span> ) {
    <span class="hljs-built_in">fprintf</span>( <span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error allocating memory.\n"</span> );
    <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
}

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Retrieve the dtype:</span>
<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">STDLIB_NDARRAY_DTYPE</span> <span class="hljs-title">dtype</span> =</span> stdlib_ndarray_dtype( x );

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Free allocated memory:</span>
stdlib_ndarray_free( x );
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
</ul>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int16_t</span> <span class="hljs-title">stdlib_ndarray_dtype</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr )</span></span>;
</code></pre>
<h4 id="stdlib_ndarray_enable_flags-arr-flags-">stdlib_ndarray_enable_flags( *arr, flags )</h4>
<p>Enables specified ndarray flags.</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/ctor.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdint.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdlib.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdio.h></span></span>

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Create an ndarray:</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ndarray</span> *<span class="hljs-title">x</span> =</span> stdlib_ndarray_allocate( ... );
<span class="hljs-keyword">if</span> ( x == <span class="hljs-literal">NULL</span> ) {
    <span class="hljs-built_in">fprintf</span>( <span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error allocating memory.\n"</span> );
    <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
}

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Enables specified ndarray flags:</span>
<span class="hljs-keyword">int8_t</span> status = stdlib_ndarray_enable_flags( x, STDLIB_NDARRAY_ROW_MAJOR_CONTIGUOUS_FLAG );

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Free allocated memory:</span>
stdlib_ndarray_free( x );
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>flags</strong>: <code>[in] int64_t</code> bit mask to enable flags.</li>
</ul>
<p>The function returns a status code of <code>0</code> if able to successfully enable flags.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_enable_flags</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> flags )</span></span>;
</code></pre>
<p>Notes:</p>
<ul>
<li>The function does not perform any sanity checks and <strong>assumes</strong> the user knows what s/he is doing.</li>
</ul>
<h4 id="stdlib_ndarray_flags-arr-">stdlib_ndarray_flags( *arr )</h4>
<p>Returns ndarray flags as a single integer value.</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/ctor.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdint.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdlib.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdio.h></span></span>

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Create an ndarray:</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ndarray</span> *<span class="hljs-title">x</span> =</span> stdlib_ndarray_allocate( ... );
<span class="hljs-keyword">if</span> ( x == <span class="hljs-literal">NULL</span> ) {
    <span class="hljs-built_in">fprintf</span>( <span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error allocating memory.\n"</span> );
    <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
}

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Retrieve the ndarray flags:</span>
<span class="hljs-keyword">int64_t</span> flags = stdlib_ndarray_flags( x );

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Free allocated memory:</span>
stdlib_ndarray_free( x );
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
</ul>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">stdlib_ndarray_flags</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr )</span></span>;
</code></pre>
<h4 id="stdlib_ndarray_free-arr-">stdlib_ndarray_free( *arr )</h4>
<p>Frees an ndarray's allocated memory.</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/ctor.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdlib.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdio.h></span></span>

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Create an ndarray:</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ndarray</span> *<span class="hljs-title">x</span> =</span> stdlib_ndarray_allocate( ... );
<span class="hljs-keyword">if</span> ( x == <span class="hljs-literal">NULL</span> ) {
    <span class="hljs-built_in">fprintf</span>( <span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error allocating memory.\n"</span> );
    <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
}

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Free allocated memory:</span>
stdlib_ndarray_free( x );
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
</ul>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stdlib_ndarray_free</span><span class="hljs-params">( struct ndarray *arr )</span></span>;
</code></pre>
<h4 id="stdlib_ndarray_has_flags-arr-flags-">stdlib_ndarray_has_flags( *arr, flags )</h4>
<p>Tests whether an ndarray has specified flags enabled.</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/ctor.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdint.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdlib.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdio.h></span></span>

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Create an ndarray:</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ndarray</span> *<span class="hljs-title">x</span> =</span> stdlib_ndarray_allocate( ... );
<span class="hljs-keyword">if</span> ( x == <span class="hljs-literal">NULL</span> ) {
    <span class="hljs-built_in">fprintf</span>( <span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error allocating memory.\n"</span> );
    <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
}

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Test whether an ndarray is row-major contiguous:</span>
<span class="hljs-keyword">int8_t</span> out = stdlib_ndarray_flags( x, STDLIB_NDARRAY_ROW_MAJOR_CONTIGUOUS_FLAG );

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Free allocated memory:</span>
stdlib_ndarray_free( x );
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>flags</strong>: <code>[in] int64_t</code> bit mask specifying flags to test against.</li>
</ul>
<p>The function returns <code>1</code> if flags are set and <code>0</code> otherwise.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_has_flags</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> flags )</span></span>;
</code></pre>
<h4 id="stdlib_ndarray_index_mode-arr-">stdlib_ndarray_index_mode( *arr )</h4>
<p>Returns the index mode of an ndarray.</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/ctor.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/index_modes.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdlib.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdio.h></span></span>

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Create an ndarray:</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ndarray</span> *<span class="hljs-title">x</span> =</span> stdlib_ndarray_allocate( ... );
<span class="hljs-keyword">if</span> ( x == <span class="hljs-literal">NULL</span> ) {
    <span class="hljs-built_in">fprintf</span>( <span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error allocating memory.\n"</span> );
    <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
}

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Retrieve the index mode:</span>
<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">STDLIB_NDARRAY_INDEX_MODE</span> <span class="hljs-title">imode</span> =</span> stdlib_ndarray_index_mode( x );

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Free allocated memory:</span>
stdlib_ndarray_free( x );
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
</ul>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_index_mode</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr )</span></span>;
</code></pre>
<h4 id="stdlib_ndarray_length-arr-">stdlib_ndarray_length( *arr )</h4>
<p>Returns the number of elements in an ndarray.</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/ctor.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdint.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdlib.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdio.h></span></span>

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Create an ndarray:</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ndarray</span> *<span class="hljs-title">x</span> =</span> stdlib_ndarray_allocate( ... );
<span class="hljs-keyword">if</span> ( x == <span class="hljs-literal">NULL</span> ) {
    <span class="hljs-built_in">fprintf</span>( <span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error allocating memory.\n"</span> );
    <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
}

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Retrieve the number of elements:</span>
<span class="hljs-keyword">int64_t</span> N = stdlib_ndarray_length( x );

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Free allocated memory:</span>
stdlib_ndarray_free( x );
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
</ul>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">stdlib_ndarray_length</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr )</span></span>;
</code></pre>
<h4 id="stdlib_ndarray_ndims-arr-">stdlib_ndarray_ndims( *arr )</h4>
<p>Returns the number of ndarray dimensions.</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/ctor.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdint.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdlib.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdio.h></span></span>

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Create an ndarray:</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ndarray</span> *<span class="hljs-title">x</span> =</span> stdlib_ndarray_allocate( ... );
<span class="hljs-keyword">if</span> ( x == <span class="hljs-literal">NULL</span> ) {
    <span class="hljs-built_in">fprintf</span>( <span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error allocating memory.\n"</span> );
    <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
}

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Retrieve the number of dimensions:</span>
<span class="hljs-keyword">int64_t</span> ndims = stdlib_ndarray_ndims( x );

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Free allocated memory:</span>
stdlib_ndarray_free( x );
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
</ul>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">stdlib_ndarray_ndims</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr )</span></span>;
</code></pre>
<h4 id="stdlib_ndarray_nsubmodes-arr-">stdlib_ndarray_nsubmodes( *arr )</h4>
<p>Returns the number of ndarray subscript modes.</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/ctor.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdint.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdlib.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdio.h></span></span>

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Create an ndarray:</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ndarray</span> *<span class="hljs-title">x</span> =</span> stdlib_ndarray_allocate( ... );
<span class="hljs-keyword">if</span> ( x == <span class="hljs-literal">NULL</span> ) {
    <span class="hljs-built_in">fprintf</span>( <span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error allocating memory.\n"</span> );
    <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
}

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Retrieve the number of index modes:</span>
<span class="hljs-keyword">int64_t</span> n = stdlib_ndarray_nsubmodes( x );

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Free allocated memory:</span>
stdlib_ndarray_free( x );
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
</ul>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">stdlib_ndarray_nsubmodes</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr )</span></span>;
</code></pre>
<h4 id="stdlib_ndarray_offset-arr-">stdlib_ndarray_offset( *arr )</h4>
<p>Returns an ndarray index offset (in bytes).</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/ctor.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdint.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdlib.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdio.h></span></span>

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Create an ndarray:</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ndarray</span> *<span class="hljs-title">x</span> =</span> stdlib_ndarray_allocate( ... );
<span class="hljs-keyword">if</span> ( x == <span class="hljs-literal">NULL</span> ) {
    <span class="hljs-built_in">fprintf</span>( <span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error allocating memory.\n"</span> );
    <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
}

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Retrieve the index offset:</span>
<span class="hljs-keyword">int64_t</span> offset = stdlib_ndarray_offset( x );

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Free allocated memory:</span>
stdlib_ndarray_free( x );
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
</ul>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">stdlib_ndarray_offset</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr )</span></span>;
</code></pre>
<h4 id="stdlib_ndarray_order-arr-">stdlib_ndarray_order( *arr )</h4>
<p>Returns the order of an ndarray.</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/ctor.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/orders.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdlib.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdio.h></span></span>

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Create an ndarray:</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ndarray</span> *<span class="hljs-title">x</span> =</span> stdlib_ndarray_allocate( ... );
<span class="hljs-keyword">if</span> ( x == <span class="hljs-literal">NULL</span> ) {
    <span class="hljs-built_in">fprintf</span>( <span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error allocating memory.\n"</span> );
    <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
}

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Retrieve the order:</span>
<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">STDLIB_NDARRAY_ORDER</span> <span class="hljs-title">order</span> =</span> stdlib_ndarray_order( x );

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Free allocated memory:</span>
stdlib_ndarray_free( x );
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
</ul>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_order</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr )</span></span>;
</code></pre>
<h4 id="stdlib_ndarray_shape-arr-">stdlib_ndarray_shape( *arr )</h4>
<p>Returns a pointer to an array containing an ndarray shape (dimensions).</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/ctor.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdint.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdlib.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdio.h></span></span>

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Create an ndarray:</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ndarray</span> *<span class="hljs-title">x</span> =</span> stdlib_ndarray_allocate( ... );
<span class="hljs-keyword">if</span> ( x == <span class="hljs-literal">NULL</span> ) {
    <span class="hljs-built_in">fprintf</span>( <span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error allocating memory.\n"</span> );
    <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
}

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Retrieve the shape:</span>
<span class="hljs-keyword">int64_t</span> *shape = stdlib_ndarray_shape( x );

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Free allocated memory:</span>
stdlib_ndarray_free( x );
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
</ul>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int64_t</span> * <span class="hljs-title">stdlib_ndarray_shape</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr )</span></span>;
</code></pre>
<h4 id="stdlib_ndarray_stride-arr-i-">stdlib_ndarray_stride( *arr, i )</h4>
<p>Returns an ndarray stride (in bytes).</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/ctor.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdint.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdlib.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdio.h></span></span>

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Create an ndarray:</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ndarray</span> *<span class="hljs-title">x</span> =</span> stdlib_ndarray_allocate( ... );
<span class="hljs-keyword">if</span> ( x == <span class="hljs-literal">NULL</span> ) {
    <span class="hljs-built_in">fprintf</span>( <span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error allocating memory.\n"</span> );
    <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
}

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Retrieve a stride:</span>
<span class="hljs-keyword">int64_t</span> s = stdlib_ndarray_stride( x, <span class="hljs-number">0</span> );

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Free allocated memory:</span>
stdlib_ndarray_free( x );
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>i</strong>: <code>[in] int64_t</code> dimension index.</li>
</ul>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">stdlib_ndarray_stride</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> i )</span></span>;
</code></pre>
<p>Notes:</p>
<ul>
<li>the function does perform bounds checking for the dimension index.</li>
</ul>
<h4 id="stdlib_ndarray_strides-arr-">stdlib_ndarray_strides( *arr )</h4>
<p>Returns a pointer to an array containing ndarray strides (in bytes).</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/ctor.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdint.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdlib.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdio.h></span></span>

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Create an ndarray:</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ndarray</span> *<span class="hljs-title">x</span> =</span> stdlib_ndarray_allocate( ... );
<span class="hljs-keyword">if</span> ( x == <span class="hljs-literal">NULL</span> ) {
    <span class="hljs-built_in">fprintf</span>( <span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error allocating memory.\n"</span> );
    <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
}

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Retrieve the strides:</span>
<span class="hljs-keyword">int64_t</span> *strides = stdlib_ndarray_strides( x );

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Free allocated memory:</span>
stdlib_ndarray_free( x );
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
</ul>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int64_t</span> * <span class="hljs-title">stdlib_ndarray_strides</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr )</span></span>;
</code></pre>
<h4 id="stdlib_ndarray_submode-arr-i-">stdlib_ndarray_submode( *arr, i )</h4>
<p>Returns an ndarray subscript mode.</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/ctor.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/index_modes.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdlib.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdio.h></span></span>

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Create an ndarray:</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ndarray</span> *<span class="hljs-title">x</span> =</span> stdlib_ndarray_allocate( ... );
<span class="hljs-keyword">if</span> ( x == <span class="hljs-literal">NULL</span> ) {
    <span class="hljs-built_in">fprintf</span>( <span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error allocating memory.\n"</span> );
    <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
}

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Retrieve an index mode:</span>
<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">STDLIB_NDARRAY_INDEX_MODE</span> <span class="hljs-title">mode</span> =</span> stdlib_ndarray_submode( x, <span class="hljs-number">0</span> );

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Free allocated memory:</span>
stdlib_ndarray_free( x );
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>i</strong>: <code>[in] int64_t</code> dimension index.</li>
</ul>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_submode</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> i )</span></span>;
</code></pre>
<p>Notes:</p>
<ul>
<li>If an ndarray has fewer subscript modes than dimensions, modes are recycled using modulo arithmetic.</li>
<li>The function does not perform bounds checking for the dimension index.</li>
</ul>
<h4 id="stdlib_ndarray_submodes-arr-">stdlib_ndarray_submodes( *arr )</h4>
<p>Returns ndarray subscript modes.</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/ctor.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/index_modes.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdlib.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdio.h></span></span>

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Create an ndarray:</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ndarray</span> *<span class="hljs-title">x</span> =</span> stdlib_ndarray_allocate( ... );
<span class="hljs-keyword">if</span> ( x == <span class="hljs-literal">NULL</span> ) {
    <span class="hljs-built_in">fprintf</span>( <span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error allocating memory.\n"</span> );
    <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
}

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Retrieve the index subscript modes:</span>
<span class="hljs-keyword">int8_t</span> *modes = stdlib_ndarray_submodes( x );

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// Free allocated memory:</span>
stdlib_ndarray_free( x );
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
</ul>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> * <span class="hljs-title">stdlib_ndarray_submodes</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr )</span></span>;
</code></pre>
<hr>
<h4 id="stdlib_ndarray_get-arr-sub-out-">stdlib_ndarray_get( *arr, *sub, *out )</h4>
<p>Returns an ndarray data element.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_get</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub, <span class="hljs-keyword">void</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray *</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t *</code> ndarray subscripts.</li>
<li><strong>out</strong>: <code>[out] void *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>The function requires a <code>void</code> pointer for the output address <code>out</code> in order to provide a generic API supporting ndarrays having different data types.</li>
</ul>
<h4 id="stdlib_ndarray_get_float64-arr-sub-out-">stdlib_ndarray_get_float64( *arr, *sub, *out )</h4>
<p>Returns a double-precision floating-point ndarray data element.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_get_float64</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub, <span class="hljs-keyword">double</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray *</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t *</code> ndarray subscripts.</li>
<li><strong>out</strong>: <code>[out] double *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>The function does <strong>not</strong> verify that the output address type matches the underlying input ndarray data type and <strong>assumes</strong> that you know what you are doing.</li>
</ul>
<h4 id="stdlib_ndarray_get_float32-arr-sub-out-">stdlib_ndarray_get_float32( *arr, *sub, *out )</h4>
<p>Returns a single-precision floating-point ndarray data element.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_get_float32</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub, <span class="hljs-keyword">float</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray *</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t *</code> ndarray subscripts.</li>
<li><strong>out</strong>: <code>[out] float *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>The function does <strong>not</strong> verify that the output address type matches the underlying input ndarray data type and <strong>assumes</strong> that you know what you are doing.</li>
</ul>
<h4 id="stdlib_ndarray_get_uint64-arr-sub-out-">stdlib_ndarray_get_uint64( *arr, *sub, *out )</h4>
<p>Returns an unsigned 64-bit integer ndarray data element.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_get_uint64</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub, <span class="hljs-keyword">uint64_t</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray *</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t *</code> ndarray subscripts.</li>
<li><strong>out</strong>: <code>[out] uint64_t *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>The function does <strong>not</strong> verify that the output address type matches the underlying input ndarray data type and <strong>assumes</strong> that you know what you are doing.</li>
</ul>
<h4 id="stdlib_ndarray_get_int64-arr-sub-out-">stdlib_ndarray_get_int64( *arr, *sub, *out )</h4>
<p>Returns a signed 64-bit integer ndarray data element.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_get_int64</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub, <span class="hljs-keyword">int64_t</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray *</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t *</code> ndarray subscripts.</li>
<li><strong>out</strong>: <code>[out] int64_t *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>The function does <strong>not</strong> verify that the output address type matches the underlying input ndarray data type and <strong>assumes</strong> that you know what you are doing.</li>
</ul>
<h4 id="stdlib_ndarray_get_uint32-arr-sub-out-">stdlib_ndarray_get_uint32( *arr, *sub, *out )</h4>
<p>Returns an unsigned 32-bit integer ndarray data element.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_get_uint32</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub, <span class="hljs-keyword">uint32_t</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray *</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t *</code> ndarray subscripts.</li>
<li><strong>out</strong>: <code>[out] uint32_t *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>The function does <strong>not</strong> verify that the output address type matches the underlying input ndarray data type and <strong>assumes</strong> that you know what you are doing.</li>
</ul>
<h4 id="stdlib_ndarray_get_int32-arr-sub-out-">stdlib_ndarray_get_int32( *arr, *sub, *out )</h4>
<p>Returns a signed 32-bit integer ndarray data element.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_get_int32</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub, <span class="hljs-keyword">int32_t</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray *</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t *</code> ndarray subscripts.</li>
<li><strong>out</strong>: <code>[out] int32_t *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>The function does <strong>not</strong> verify that the output address type matches the underlying input ndarray data type and <strong>assumes</strong> that you know what you are doing.</li>
</ul>
<h4 id="stdlib_ndarray_get_uint16-arr-sub-out-">stdlib_ndarray_get_uint16( *arr, *sub, *out )</h4>
<p>Returns an unsigned 16-bit integer ndarray data element.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_get_uint16</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub, <span class="hljs-keyword">uint16_t</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray *</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t *</code> ndarray subscripts.</li>
<li><strong>out</strong>: <code>[out] uint16_t *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>The function does <strong>not</strong> verify that the output address type matches the underlying input ndarray data type and <strong>assumes</strong> that you know what you are doing.</li>
</ul>
<h4 id="stdlib_ndarray_get_int16-arr-sub-out-">stdlib_ndarray_get_int16( *arr, *sub, *out )</h4>
<p>Returns a signed 16-bit integer ndarray data element.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_get_int16</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub, <span class="hljs-keyword">int16_t</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray *</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t *</code> ndarray subscripts.</li>
<li><strong>out</strong>: <code>[out] int16_t *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>The function does <strong>not</strong> verify that the output address type matches the underlying input ndarray data type and <strong>assumes</strong> that you know what you are doing.</li>
</ul>
<h4 id="stdlib_ndarray_get_uint8-arr-sub-out-">stdlib_ndarray_get_uint8( *arr, *sub, *out )</h4>
<p>Returns an unsigned 8-bit integer ndarray data element.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_get_uint8</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub, <span class="hljs-keyword">uint8_t</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray *</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t *</code> ndarray subscripts.</li>
<li><strong>out</strong>: <code>[out] uint8_t *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>The function does <strong>not</strong> verify that the output address type matches the underlying input ndarray data type and <strong>assumes</strong> that you know what you are doing.</li>
</ul>
<h4 id="stdlib_ndarray_get_int8-arr-sub-out-">stdlib_ndarray_get_int8( *arr, *sub, *out )</h4>
<p>Returns a signed 8-bit integer ndarray data element.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_get_int8</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub, <span class="hljs-keyword">int8_t</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray *</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t *</code> ndarray subscripts.</li>
<li><strong>out</strong>: <code>[out] int8_t *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>The function does <strong>not</strong> verify that the output address type matches the underlying input ndarray data type and <strong>assumes</strong> that you know what you are doing.</li>
</ul>
<h4 id="stdlib_ndarray_get_complex128-arr-sub-out-">stdlib_ndarray_get_complex128( *arr, *sub, *out )</h4>
<p>Returns a double-precision complex floating-point ndarray data element.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_get_complex128</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub, <span class="hljs-keyword">double</span> <span class="hljs-built_in">complex</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray *</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t *</code> ndarray subscripts.</li>
<li><strong>out</strong>: <code>[out] double complex *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>The function does <strong>not</strong> verify that the output address type matches the underlying input ndarray data type and <strong>assumes</strong> that you know what you are doing.</li>
</ul>
<h4 id="stdlib_ndarray_get_complex64-arr-sub-out-">stdlib_ndarray_get_complex64( *arr, *sub, *out )</h4>
<p>Returns a single-precision complex floating-point ndarray data element.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_get_complex64</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub, <span class="hljs-keyword">float</span> <span class="hljs-built_in">complex</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray *</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t *</code> ndarray subscripts.</li>
<li><strong>out</strong>: <code>[out] float complex *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>The function does <strong>not</strong> verify that the output address type matches the underlying input ndarray data type and <strong>assumes</strong> that you know what you are doing.</li>
</ul>
<h4 id="stdlib_ndarray_get_bool-arr-sub-out-">stdlib_ndarray_get_bool( *arr, *sub, *out )</h4>
<p>Returns a boolean ndarray data element.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_get_bool</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub, <span class="hljs-keyword">bool</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray *</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t *</code> ndarray subscripts.</li>
<li><strong>out</strong>: <code>[out] bool *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>The function does <strong>not</strong> verify that the output address type matches the underlying input ndarray data type and <strong>assumes</strong> that you know what you are doing.</li>
</ul>
<hr>
<h4 id="stdlib_ndarray_get_ptr-arr-sub-">stdlib_ndarray_get_ptr( *arr, *sub )</h4>
<p>Returns a pointer to an ndarray data element in the underlying byte array.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">uint8_t</span> * <span class="hljs-title">stdlib_ndarray_get_ptr</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray *</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t *</code> ndarray subscripts.</li>
</ul>
<h4 id="stdlib_ndarray_get_ptr_value-arr-idx-out-">stdlib_ndarray_get_ptr_value( *arr, *idx, *out )</h4>
<p>Returns an ndarray data element specified by a byte array pointer.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_get_ptr_value</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *idx, <span class="hljs-keyword">void</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray *</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] uint8_t *</code> byte array pointer to an ndarray data element.</li>
<li><strong>out</strong>: <code>[out] void *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function does <strong>not</strong> perform bounds checking and <strong>assumes</strong> you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>The function requires a <code>void</code> pointer for the output address <code>out</code> in order to provide a generic API supporting ndarrays having different data types.</li>
</ul>
<h4 id="stdlib_ndarray_get_ptr_float64-idx-out-">stdlib_ndarray_get_ptr_float64( *idx, *out )</h4>
<p>Returns a double-precision floating-point ndarray data element specified by a byte array pointer.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_get_ptr_float64</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *idx, <span class="hljs-keyword">double</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>idx</strong>: <code>[in] uint8_t *</code> byte array pointer to an ndarray data element.</li>
<li><strong>out</strong>: <code>[out] double *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function has no way of determining whether <code>idx</code> actually points to a compatible memory address. Accordingly, accessing <strong>unowned</strong> memory is possible, and this function <strong>assumes</strong> you know what you are doing.</li>
<li>The function always returns <code>0</code>.</li>
</ul>
<h4 id="stdlib_ndarray_get_ptr_float32-idx-out-">stdlib_ndarray_get_ptr_float32( *idx, *out )</h4>
<p>Returns a single-precision floating-point ndarray data element specified by a byte array pointer.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_get_ptr_float32</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *idx, <span class="hljs-keyword">float</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>idx</strong>: <code>[in] uint8_t *</code> byte array pointer to an ndarray data element.</li>
<li><strong>out</strong>: <code>[out] float *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function has no way of determining whether <code>idx</code> actually points to a compatible memory address. Accordingly, accessing <strong>unowned</strong> memory is possible, and this function <strong>assumes</strong> you know what you are doing.</li>
<li>The function always returns <code>0</code>.</li>
</ul>
<h4 id="stdlib_ndarray_get_ptr_uint64-idx-out-">stdlib_ndarray_get_ptr_uint64( *idx, *out )</h4>
<p>Returns an unsigned 64-bit integer ndarray data element specified by a byte array pointer.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_get_ptr_uint64</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *idx, <span class="hljs-keyword">uint64_t</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>idx</strong>: <code>[in] uint8_t *</code> byte array pointer to an ndarray data element.</li>
<li><strong>out</strong>: <code>[out] uint64_t *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function has no way of determining whether <code>idx</code> actually points to a compatible memory address. Accordingly, accessing <strong>unowned</strong> memory is possible, and this function <strong>assumes</strong> you know what you are doing.</li>
<li>The function always returns <code>0</code>.</li>
</ul>
<h4 id="stdlib_ndarray_get_ptr_int64-idx-out-">stdlib_ndarray_get_ptr_int64( *idx, *out )</h4>
<p>Returns a signed 64-bit integer ndarray data element specified by a byte array pointer.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_get_ptr_int64</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *idx, <span class="hljs-keyword">int64_t</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>idx</strong>: <code>[in] uint8_t *</code> byte array pointer to an ndarray data element.</li>
<li><strong>out</strong>: <code>[out] int64_t *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function has no way of determining whether <code>idx</code> actually points to a compatible memory address. Accordingly, accessing <strong>unowned</strong> memory is possible, and this function <strong>assumes</strong> you know what you are doing.</li>
<li>The function always returns <code>0</code>.</li>
</ul>
<h4 id="stdlib_ndarray_get_ptr_uint32-idx-out-">stdlib_ndarray_get_ptr_uint32( *idx, *out )</h4>
<p>Returns an unsigned 32-bit integer ndarray data element specified by a byte array pointer.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_get_ptr_uint32</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *idx, <span class="hljs-keyword">uint32_t</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>idx</strong>: <code>[in] uint8_t *</code> byte array pointer to an ndarray data element.</li>
<li><strong>out</strong>: <code>[out] uint32_t *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function has no way of determining whether <code>idx</code> actually points to a compatible memory address. Accordingly, accessing <strong>unowned</strong> memory is possible, and this function <strong>assumes</strong> you know what you are doing.</li>
<li>The function always returns <code>0</code>.</li>
</ul>
<h4 id="stdlib_ndarray_get_ptr_int32-idx-out-">stdlib_ndarray_get_ptr_int32( *idx, *out )</h4>
<p>Returns a signed 32-bit integer ndarray data element specified by a byte array pointer.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_get_ptr_int32</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *idx, <span class="hljs-keyword">int32_t</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>idx</strong>: <code>[in] uint8_t *</code> byte array pointer to an ndarray data element.</li>
<li><strong>out</strong>: <code>[out] int32_t *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function has no way of determining whether <code>idx</code> actually points to a compatible memory address. Accordingly, accessing <strong>unowned</strong> memory is possible, and this function <strong>assumes</strong> you know what you are doing.</li>
<li>The function always returns <code>0</code>.</li>
</ul>
<h4 id="stdlib_ndarray_get_ptr_uint16-idx-out-">stdlib_ndarray_get_ptr_uint16( *idx, *out )</h4>
<p>Returns an unsigned 16-bit integer ndarray data element specified by a byte array pointer.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_get_ptr_uint16</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *idx, <span class="hljs-keyword">uint16_t</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>idx</strong>: <code>[in] uint8_t *</code> byte array pointer to an ndarray data element.</li>
<li><strong>out</strong>: <code>[out] uint16_t *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function has no way of determining whether <code>idx</code> actually points to a compatible memory address. Accordingly, accessing <strong>unowned</strong> memory is possible, and this function <strong>assumes</strong> you know what you are doing.</li>
<li>The function always returns <code>0</code>.</li>
</ul>
<h4 id="stdlib_ndarray_get_ptr_int16-idx-out-">stdlib_ndarray_get_ptr_int16( *idx, *out )</h4>
<p>Returns a signed 16-bit integer ndarray data element specified by a byte array pointer.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_get_ptr_int16</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *idx, <span class="hljs-keyword">int16_t</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>idx</strong>: <code>[in] uint8_t *</code> byte array pointer to an ndarray data element.</li>
<li><strong>out</strong>: <code>[out] int16_t *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function has no way of determining whether <code>idx</code> actually points to a compatible memory address. Accordingly, accessing <strong>unowned</strong> memory is possible, and this function <strong>assumes</strong> you know what you are doing.</li>
<li>The function always returns <code>0</code>.</li>
</ul>
<h4 id="stdlib_ndarray_get_ptr_uint8-idx-out-">stdlib_ndarray_get_ptr_uint8( *idx, *out )</h4>
<p>Returns an unsigned 8-bit integer ndarray data element specified by a byte array pointer.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_get_ptr_uint8</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *idx, <span class="hljs-keyword">uint8_t</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>idx</strong>: <code>[in] uint8_t *</code> byte array pointer to an ndarray data element.</li>
<li><strong>out</strong>: <code>[out] uint8_t *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function always returns <code>0</code>.</li>
</ul>
<h4 id="stdlib_ndarray_get_ptr_int8-idx-out-">stdlib_ndarray_get_ptr_int8( *idx, *out )</h4>
<p>Returns a signed 8-bit integer ndarray data element specified by a byte array pointer.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_get_ptr_int8</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *idx, <span class="hljs-keyword">int8_t</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>idx</strong>: <code>[in] uint8_t *</code> byte array pointer to an ndarray data element.</li>
<li><strong>out</strong>: <code>[out] int8_t *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function always returns <code>0</code>.</li>
</ul>
<h4 id="stdlib_ndarray_get_ptr_complex128-idx-out-">stdlib_ndarray_get_ptr_complex128( *idx, *out )</h4>
<p>Returns a double-precision complex floating-point ndarray data element specified by a byte array pointer.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_get_ptr_complex128</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *idx, <span class="hljs-keyword">double</span> <span class="hljs-built_in">complex</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>idx</strong>: <code>[in] uint8_t *</code> byte array pointer to an ndarray data element.</li>
<li><strong>out</strong>: <code>[out] double complex *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function has no way of determining whether <code>idx</code> actually points to a compatible memory address. Accordingly, accessing <strong>unowned</strong> memory is possible, and this function <strong>assumes</strong> you know what you are doing.</li>
<li>The function always returns <code>0</code>.</li>
</ul>
<h4 id="stdlib_ndarray_get_ptr_complex64-idx-out-">stdlib_ndarray_get_ptr_complex64( *idx, *out )</h4>
<p>Returns a single-precision complex floating-point ndarray data element specified by a byte array pointer.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_get_ptr_complex64</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *idx, <span class="hljs-keyword">float</span> <span class="hljs-built_in">complex</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>idx</strong>: <code>[in] uint8_t *</code> byte array pointer to an ndarray data element.</li>
<li><strong>out</strong>: <code>[out] float complex *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function has no way of determining whether <code>idx</code> actually points to a compatible memory address. Accordingly, accessing <strong>unowned</strong> memory is possible, and this function <strong>assumes</strong> you know what you are doing.</li>
<li>The function always returns <code>0</code>.</li>
</ul>
<h4 id="stdlib_ndarray_get_ptr_bool-idx-out-">stdlib_ndarray_get_ptr_bool( *idx, *out )</h4>
<p>Returns a boolean ndarray data element specified by a byte array pointer.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_get_ptr_bool</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *idx, <span class="hljs-keyword">bool</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>idx</strong>: <code>[in] uint8_t *</code> byte array pointer to an ndarray data element.</li>
<li><strong>out</strong>: <code>[out] bool *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function has no way of determining whether <code>idx</code> actually points to a compatible memory address. Accordingly, accessing <strong>unowned</strong> memory is possible, and this function <strong>assumes</strong> you know what you are doing.</li>
<li>The function always returns <code>0</code>.</li>
</ul>
<hr>
<h4 id="stdlib_ndarray_iget-arr-idx-out-">stdlib_ndarray_iget( *arr, idx, *out )</h4>
<p>Returns an ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_iget</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx, <span class="hljs-keyword">void</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
<li><strong>out</strong>: <code>[out] void *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>The function requires a <code>void</code> pointer for the output address <code>out</code> in order to provide a generic API supporting ndarrays having different data types.</li>
<li>The function places the burden on the user to ensure that the output address is compatible with the data type of input ndarray data elements.</li>
<li>For zero-dimensional arrays, the function returns the first (and only) indexed element, regardless of the value of <code>idx</code>.</li>
</ul>
<h4 id="stdlib_ndarray_iget_float64-arr-idx-out-">stdlib_ndarray_iget_float64( *arr, idx, *out )</h4>
<p>Returns a double-precision floating-point ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_iget_float64</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx, <span class="hljs-keyword">double</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
<li><strong>out</strong>: <code>[out] double *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function does <strong>not</strong> verify that the output address type matches the underlying input ndarray data type and <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>For zero-dimensional arrays, the function returns the first (and only) indexed element, regardless of the value of <code>idx</code>.</li>
</ul>
<h4 id="stdlib_ndarray_iget_float32-arr-idx-out-">stdlib_ndarray_iget_float32( *arr, idx, *out )</h4>
<p>Returns a single-precision floating-point ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_iget_float32</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx, <span class="hljs-keyword">float</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
<li><strong>out</strong>: <code>[out] float *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function does <strong>not</strong> verify that the output address type matches the underlying input ndarray data type and <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>For zero-dimensional arrays, the function returns the first (and only) indexed element, regardless of the value of <code>idx</code>.</li>
</ul>
<h4 id="stdlib_ndarray_iget_uint64-arr-idx-out-">stdlib_ndarray_iget_uint64( *arr, idx, *out )</h4>
<p>Returns an unsigned 64-bit integer ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_iget_uint64</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx, <span class="hljs-keyword">uint64_t</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
<li><strong>out</strong>: <code>[out] uint64_t *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function does <strong>not</strong> verify that the output address type matches the underlying input ndarray data type and <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>For zero-dimensional arrays, the function returns the first (and only) indexed element, regardless of the value of <code>idx</code>.</li>
</ul>
<h4 id="stdlib_ndarray_iget_int64-arr-idx-out-">stdlib_ndarray_iget_int64( *arr, idx, *out )</h4>
<p>Returns a signed 64-bit integer ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_iget_int64</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx, <span class="hljs-keyword">int64_t</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
<li><strong>out</strong>: <code>[out] int64_t *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function does <strong>not</strong> verify that the output address type matches the underlying input ndarray data type and <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>For zero-dimensional arrays, the function returns the first (and only) indexed element, regardless of the value of <code>idx</code>.</li>
</ul>
<h4 id="stdlib_ndarray_iget_uint32-arr-idx-out-">stdlib_ndarray_iget_uint32( *arr, idx, *out )</h4>
<p>Returns an unsigned 32-bit integer ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_iget_uint32</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx, <span class="hljs-keyword">uint32_t</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
<li><strong>out</strong>: <code>[out] uint32_t *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function does <strong>not</strong> verify that the output address type matches the underlying input ndarray data type and <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>For zero-dimensional arrays, the function returns the first (and only) indexed element, regardless of the value of <code>idx</code>.</li>
</ul>
<h4 id="stdlib_ndarray_iget_int32-arr-idx-out-">stdlib_ndarray_iget_int32( *arr, idx, *out )</h4>
<p>Returns a signed 32-bit integer ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_iget_int32</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx, <span class="hljs-keyword">int32_t</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
<li><strong>out</strong>: <code>[out] int32_t *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function does <strong>not</strong> verify that the output address type matches the underlying input ndarray data type and <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>For zero-dimensional arrays, the function returns the first (and only) indexed element, regardless of the value of <code>idx</code>.</li>
</ul>
<h4 id="stdlib_ndarray_iget_uint16-arr-idx-out-">stdlib_ndarray_iget_uint16( *arr, idx, *out )</h4>
<p>Returns an unsigned 16-bit integer ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_iget_uint16</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx, <span class="hljs-keyword">uint16_t</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
<li><strong>out</strong>: <code>[out] uint16_t *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function does <strong>not</strong> verify that the output address type matches the underlying input ndarray data type and <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>For zero-dimensional arrays, the function returns the first (and only) indexed element, regardless of the value of <code>idx</code>.</li>
</ul>
<h4 id="stdlib_ndarray_iget_int16-arr-idx-out-">stdlib_ndarray_iget_int16( *arr, idx, *out )</h4>
<p>Returns a signed 16-bit integer ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_iget_int16</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx, <span class="hljs-keyword">int16_t</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
<li><strong>out</strong>: <code>[out] int16_t *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function does <strong>not</strong> verify that the output address type matches the underlying input ndarray data type and <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>For zero-dimensional arrays, the function returns the first (and only) indexed element, regardless of the value of <code>idx</code>.</li>
</ul>
<h4 id="stdlib_ndarray_iget_uint8-arr-idx-out-">stdlib_ndarray_iget_uint8( *arr, idx, *out )</h4>
<p>Returns an unsigned 8-bit integer ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_iget_uint8</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx, <span class="hljs-keyword">uint8_t</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
<li><strong>out</strong>: <code>[out] uint8_t *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function does <strong>not</strong> verify that the output address type matches the underlying input ndarray data type and <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>For zero-dimensional arrays, the function returns the first (and only) indexed element, regardless of the value of <code>idx</code>.</li>
</ul>
<h4 id="stdlib_ndarray_iget_int8-arr-idx-out-">stdlib_ndarray_iget_int8( *arr, idx, *out )</h4>
<p>Returns a signed 8-bit integer ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_iget_int8</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx, <span class="hljs-keyword">int8_t</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
<li><strong>out</strong>: <code>[out] int8_t *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function does <strong>not</strong> verify that the output address type matches the underlying input ndarray data type and <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>For zero-dimensional arrays, the function returns the first (and only) indexed element, regardless of the value of <code>idx</code>.</li>
</ul>
<h4 id="stdlib_ndarray_iget_complex128-arr-idx-out-">stdlib_ndarray_iget_complex128( *arr, idx, *out )</h4>
<p>Returns a double-precision complex floating-point ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_iget_complex128</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx, <span class="hljs-keyword">double</span> <span class="hljs-built_in">complex</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
<li><strong>out</strong>: <code>[out] double complex *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function does <strong>not</strong> verify that the output address type matches the underlying input ndarray data type and <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>For zero-dimensional arrays, the function returns the first (and only) indexed element, regardless of the value of <code>idx</code>.</li>
</ul>
<h4 id="stdlib_ndarray_iget_complex64-arr-idx-out-">stdlib_ndarray_iget_complex64( *arr, idx, *out )</h4>
<p>Returns a single-precision complex floating-point ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_iget_complex64</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx, <span class="hljs-keyword">float</span> <span class="hljs-built_in">complex</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
<li><strong>out</strong>: <code>[out] float complex *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function does <strong>not</strong> verify that the output address type matches the underlying input ndarray data type and <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>For zero-dimensional arrays, the function returns the first (and only) indexed element, regardless of the value of <code>idx</code>.</li>
</ul>
<h4 id="stdlib_ndarray_iget_bool-arr-idx-out-">stdlib_ndarray_iget_bool( *arr, idx, *out )</h4>
<p>Returns a boolean ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_iget_bool</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx, <span class="hljs-keyword">bool</span> *out )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
<li><strong>out</strong>: <code>[out] bool *</code> output address.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function does <strong>not</strong> verify that the output address type matches the underlying input ndarray data type and <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to get an element and <code>0</code> otherwise.</li>
<li>For zero-dimensional arrays, the function returns the first (and only) indexed element, regardless of the value of <code>idx</code>.</li>
</ul>
<hr>
<h4 id="stdlib_ndarray_iget_ptr-arr-idx-">stdlib_ndarray_iget_ptr( *arr, idx )</h4>
<p>Returns a pointer in the underlying byte array for an ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">uint8_t</span> * <span class="hljs-title">stdlib_ndarray_iget_ptr</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
</ul>
<p>For zero-dimensional arrays, the function returns a pointer to the first (and only) indexed element, regardless of the value of <code>idx</code>.</p>
<hr>
<h4 id="stdlib_ndarray_iset-arr-idx-v-">stdlib_ndarray_iset( *arr, idx, *v )</h4>
<p>Sets an ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_iset</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
<li><strong>v</strong>: <code>[in] void*</code> value to set.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
<li>The function requires a pointer to a data value <code>v</code> in order to provide a generic API supporting ndarrays having different data types.</li>
<li>The function has no way of determining whether <code>v</code> actually points to a memory address compatible with the underlying input ndarray data type. Accordingly, accessing <strong>unowned</strong> memory is possible, and this function <strong>assumes</strong> you know what you are doing.</li>
<li>For zero-dimensional arrays, the function sets the first (and only) indexed element, regardless of the value of <code>idx</code>.</li>
</ul>
<h4 id="stdlib_ndarray_iset_float64-arr-idx-v-">stdlib_ndarray_iset_float64( *arr, idx, v )</h4>
<p>Sets a double-precision floating-point ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_iset_float64</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
<li><strong>v</strong>: <code>[in] double</code> value to set.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function does <strong>not</strong> verify that the type of <code>v</code> matches the underlying input ndarray data type, and, thus, overwriting <strong>unowned</strong> memory is possible. The function <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
<li>For zero-dimensional arrays, the function sets the first (and only) indexed element, regardless of the value of <code>idx</code>.</li>
</ul>
<h4 id="stdlib_ndarray_iset_float32-arr-idx-v-">stdlib_ndarray_iset_float32( *arr, idx, v )</h4>
<p>Sets a single-precision floating-point ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_iset_float32</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
<li><strong>v</strong>: <code>[in] float</code> value to set.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function does <strong>not</strong> verify that the type of <code>v</code> matches the underlying input ndarray data type, and, thus, overwriting <strong>unowned</strong> memory is possible. The function <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
<li>For zero-dimensional arrays, the function sets the first (and only) indexed element, regardless of the value of <code>idx</code>.</li>
</ul>
<h4 id="stdlib_ndarray_iset_uint64-arr-idx-v-">stdlib_ndarray_iset_uint64( *arr, idx, v )</h4>
<p>Sets an unsigned 64-bit integer ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_iset_uint64</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint64_t</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
<li><strong>v</strong>: <code>[in] uint64_t</code> value to set.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function does <strong>not</strong> verify that the type of <code>v</code> matches the underlying input ndarray data type, and, thus, overwriting <strong>unowned</strong> memory is possible. The function <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
<li>For zero-dimensional arrays, the function sets the first (and only) indexed element, regardless of the value of <code>idx</code>.</li>
</ul>
<h4 id="stdlib_ndarray_iset_int64-arr-idx-v-">stdlib_ndarray_iset_int64( *arr, idx, v )</h4>
<p>Sets a signed 64-bit integer ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_iset_int64</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
<li><strong>v</strong>: <code>[in] int64_t</code> value to set.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function does <strong>not</strong> verify that the type of <code>v</code> matches the underlying input ndarray data type, and, thus, overwriting <strong>unowned</strong> memory is possible. The function <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
<li>For zero-dimensional arrays, the function sets the first (and only) indexed element, regardless of the value of <code>idx</code>.</li>
</ul>
<h4 id="stdlib_ndarray_iset_uint32-arr-idx-v-">stdlib_ndarray_iset_uint32( *arr, idx, v )</h4>
<p>Sets an unsigned 32-bit integer ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_iset_uint32</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
<li><strong>v</strong>: <code>[in] uint32_t</code> value to set.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function does <strong>not</strong> verify that the type of <code>v</code> matches the underlying input ndarray data type, and, thus, overwriting <strong>unowned</strong> memory is possible. The function <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
<li>For zero-dimensional arrays, the function sets the first (and only) indexed element, regardless of the value of <code>idx</code>.</li>
</ul>
<h4 id="stdlib_ndarray_iset_int32-arr-idx-v-">stdlib_ndarray_iset_int32( *arr, idx, v )</h4>
<p>Sets a signed 32-bit integer ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_iset_int32</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int32_t</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
<li><strong>v</strong>: <code>[in] int32_t</code> value to set.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function does <strong>not</strong> verify that the type of <code>v</code> matches the underlying input ndarray data type, and, thus, overwriting <strong>unowned</strong> memory is possible. The function <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
<li>For zero-dimensional arrays, the function sets the first (and only) indexed element, regardless of the value of <code>idx</code>.</li>
</ul>
<h4 id="stdlib_ndarray_iset_uint16-arr-idx-v-">stdlib_ndarray_iset_uint16( *arr, idx, v )</h4>
<p>Sets an unsigned 16-bit integer ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_iset_uint16</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint16_t</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
<li><strong>v</strong>: <code>[in] uint16_t</code> value to set.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function does <strong>not</strong> verify that the type of <code>v</code> matches the underlying input ndarray data type, and, thus, overwriting <strong>unowned</strong> memory is possible. The function <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
<li>For zero-dimensional arrays, the function sets the first (and only) indexed element, regardless of the value of <code>idx</code>.</li>
</ul>
<h4 id="stdlib_ndarray_iset_int16-arr-idx-v-">stdlib_ndarray_iset_int16( *arr, idx, v )</h4>
<p>Sets a signed 16-bit integer ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_iset_int16</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int16_t</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
<li><strong>v</strong>: <code>[in] int16_t</code> value to set.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function does <strong>not</strong> verify that the type of <code>v</code> matches the underlying input ndarray data type, and, thus, overwriting <strong>unowned</strong> memory is possible. The function <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
<li>For zero-dimensional arrays, the function sets the first (and only) indexed element, regardless of the value of <code>idx</code>.</li>
</ul>
<h4 id="stdlib_ndarray_iset_uint8-arr-idx-v-">stdlib_ndarray_iset_uint8( *arr, idx, v )</h4>
<p>Sets an unsigned 8-bit integer ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_iset_uint8</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
<li><strong>v</strong>: <code>[in] uint8_t</code> value to set.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
<li>For zero-dimensional arrays, the function sets the first (and only) indexed element, regardless of the value of <code>idx</code>.</li>
</ul>
<h4 id="stdlib_ndarray_iset_int8-arr-idx-v-">stdlib_ndarray_iset_int8( *arr, idx, v )</h4>
<p>Sets a signed 8-bit integer ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_iset_int8</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int8_t</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
<li><strong>v</strong>: <code>[in] int8_t</code> value to set.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
<li>For zero-dimensional arrays, the function sets the first (and only) indexed element, regardless of the value of <code>idx</code>.</li>
</ul>
<h4 id="stdlib_ndarray_iset_complex128-arr-idx-v-">stdlib_ndarray_iset_complex128( *arr, idx, v )</h4>
<p>Sets a double-precision complex floating-point ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_iset_complex128</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> <span class="hljs-built_in">complex</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
<li><strong>v</strong>: <code>[in] double complex</code> value to set.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function does <strong>not</strong> verify that the type of <code>v</code> matches the underlying input ndarray data type, and, thus, overwriting <strong>unowned</strong> memory is possible. The function <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
<li>For zero-dimensional arrays, the function sets the first (and only) indexed element, regardless of the value of <code>idx</code>.</li>
</ul>
<h4 id="stdlib_ndarray_iset_complex64-arr-idx-v-">stdlib_ndarray_iset_complex64( *arr, idx, v )</h4>
<p>Sets a single-precision complex floating-point ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_iset_complex64</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> <span class="hljs-built_in">complex</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
<li><strong>v</strong>: <code>[in] float complex</code> value to set.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function does <strong>not</strong> verify that the type of <code>v</code> matches the underlying input ndarray data type, and, thus, overwriting <strong>unowned</strong> memory is possible. The function <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
<li>For zero-dimensional arrays, the function sets the first (and only) indexed element, regardless of the value of <code>idx</code>.</li>
</ul>
<h4 id="stdlib_ndarray_iset_bool-arr-idx-v-">stdlib_ndarray_iset_bool( *arr, idx, v )</h4>
<p>Sets a boolean ndarray data element located at a specified linear index.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_iset_bool</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> idx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] int64_t</code> linear view index.</li>
<li><strong>v</strong>: <code>[in] bool</code> value to set.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function does <strong>not</strong> verify that the type of <code>v</code> matches the underlying input ndarray data type, and, thus, overwriting <strong>unowned</strong> memory is possible. The function <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
<li>For zero-dimensional arrays, the function sets the first (and only) indexed element, regardless of the value of <code>idx</code>.</li>
</ul>
<hr>
<h4 id="stdlib_ndarray_set-arr-sub-v-">stdlib_ndarray_set( *arr, *sub, *v )</h4>
<p>Sets an ndarray data element.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_set</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t*</code> ndarray subscripts.</li>
<li><strong>v</strong>: <code>[in] void*</code> value to set.</li>
</ul>
<p>Notes</p>
<ul>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
<li>The function requires a pointer to a data value <code>v</code> in order to provide a generic API supporting ndarrays having different data types.</li>
<li>The function has no way of determining whether <code>v</code> actually points to a memory address compatible with the underlying input ndarray data type. Accordingly, accessing <strong>unowned</strong> memory is possible, and this function <strong>assumes</strong> you know what you are doing.</li>
</ul>
<h4 id="stdlib_ndarray_set_float64-arr-sub-v-">stdlib_ndarray_set_float64( *arr, *sub, v )</h4>
<p>Sets a double-precision floating-point ndarray data element.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_set_float64</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub, <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t*</code> ndarray subscripts.</li>
<li><strong>v</strong>: <code>[in] double</code> value to set.</li>
</ul>
<p>Notes</p>
<ul>
<li>The function does <strong>not</strong> verify that the type of <code>v</code> matches the underlying input ndarray data type, and, thus, overwriting <strong>unowned</strong> memory is possible. The function <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
</ul>
<h4 id="stdlib_ndarray_set_float32-arr-sub-v-">stdlib_ndarray_set_float32( *arr, *sub, v )</h4>
<p>Sets a single-precision floating-point ndarray data element.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_set_float32</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub, <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t*</code> ndarray subscripts.</li>
<li><strong>v</strong>: <code>[in] float</code> value to set.</li>
</ul>
<p>Notes</p>
<ul>
<li>The function does <strong>not</strong> verify that the type of <code>v</code> matches the underlying input ndarray data type, and, thus, overwriting <strong>unowned</strong> memory is possible. The function <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
</ul>
<h4 id="stdlib_ndarray_set_uint64-arr-sub-v-">stdlib_ndarray_set_uint64( *arr, *sub, v )</h4>
<p>Sets an unsigned 64-bit integer ndarray data element.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_set_uint64</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint64_t</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t*</code> ndarray subscripts.</li>
<li><strong>v</strong>: <code>[in] uint64_t</code> value to set.</li>
</ul>
<p>Notes</p>
<ul>
<li>The function does <strong>not</strong> verify that the type of <code>v</code> matches the underlying input ndarray data type, and, thus, overwriting <strong>unowned</strong> memory is possible. The function <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
</ul>
<h4 id="stdlib_ndarray_set_int64-arr-sub-v-">stdlib_ndarray_set_int64( *arr, *sub, v )</h4>
<p>Sets a signed 64-bit integer ndarray data element.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_set_int64</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t*</code> ndarray subscripts.</li>
<li><strong>v</strong>: <code>[in] int64_t</code> value to set.</li>
</ul>
<p>Notes</p>
<ul>
<li>The function does <strong>not</strong> verify that the type of <code>v</code> matches the underlying input ndarray data type, and, thus, overwriting <strong>unowned</strong> memory is possible. The function <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
</ul>
<h4 id="stdlib_ndarray_set_uint32-arr-sub-v-">stdlib_ndarray_set_uint32( *arr, *sub, v )</h4>
<p>Sets an unsigned 32-bit integer ndarray data element.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_set_uint32</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t*</code> ndarray subscripts.</li>
<li><strong>v</strong>: <code>[in] uint32_t</code> value to set.</li>
</ul>
<p>Notes</p>
<ul>
<li>The function does <strong>not</strong> verify that the type of <code>v</code> matches the underlying input ndarray data type, and, thus, overwriting <strong>unowned</strong> memory is possible. The function <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
</ul>
<h4 id="stdlib_ndarray_set_int32-arr-sub-v-">stdlib_ndarray_set_int32( *arr, *sub, v )</h4>
<p>Sets a signed 32-bit integer ndarray data element.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_set_int32</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int32_t</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t*</code> ndarray subscripts.</li>
<li><strong>v</strong>: <code>[in] int32_t</code> value to set.</li>
</ul>
<p>Notes</p>
<ul>
<li>The function does <strong>not</strong> verify that the type of <code>v</code> matches the underlying input ndarray data type, and, thus, overwriting <strong>unowned</strong> memory is possible. The function <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
</ul>
<h4 id="stdlib_ndarray_set_uint16-arr-sub-v-">stdlib_ndarray_set_uint16( *arr, *sub, v )</h4>
<p>Sets an unsigned 16-bit integer ndarray data element.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_set_uint16</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint16_t</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t*</code> ndarray subscripts.</li>
<li><strong>v</strong>: <code>[in] uint16_t</code> value to set.</li>
</ul>
<p>Notes</p>
<ul>
<li>The function does <strong>not</strong> verify that the type of <code>v</code> matches the underlying input ndarray data type, and, thus, overwriting <strong>unowned</strong> memory is possible. The function <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
</ul>
<h4 id="stdlib_ndarray_set_int16-arr-sub-v-">stdlib_ndarray_set_int16( *arr, *sub, v )</h4>
<p>Sets a signed 16-bit integer ndarray data element.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_set_int16</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int16_t</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t*</code> ndarray subscripts.</li>
<li><strong>v</strong>: <code>[in] int16_t</code> value to set.</li>
</ul>
<p>Notes</p>
<ul>
<li>The function does <strong>not</strong> verify that the type of <code>v</code> matches the underlying input ndarray data type, and, thus, overwriting <strong>unowned</strong> memory is possible. The function <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
</ul>
<h4 id="stdlib_ndarray_set_uint8-arr-sub-v-">stdlib_ndarray_set_uint8( *arr, *sub, v )</h4>
<p>Sets an unsigned 8-bit integer ndarray data element.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_set_uint8</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t*</code> ndarray subscripts.</li>
<li><strong>v</strong>: <code>[in] uint8_t</code> value to set.</li>
</ul>
<p>Notes</p>
<ul>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
</ul>
<h4 id="stdlib_ndarray_set_int8-arr-sub-v-">stdlib_ndarray_set_int8( *arr, *sub, v )</h4>
<p>Sets a signed 8-bit integer ndarray data element.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_set_int8</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int8_t</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t*</code> ndarray subscripts.</li>
<li><strong>v</strong>: <code>[in] int8_t</code> value to set.</li>
</ul>
<p>Notes</p>
<ul>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
</ul>
<h4 id="stdlib_ndarray_set_complex128-arr-sub-v-">stdlib_ndarray_set_complex128( *arr, *sub, v )</h4>
<p>Sets a double-precision complex floating-point ndarray data element.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_set_complex128</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub, <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> <span class="hljs-built_in">complex</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t*</code> ndarray subscripts.</li>
<li><strong>v</strong>: <code>[in] double complex</code> value to set.</li>
</ul>
<p>Notes</p>
<ul>
<li>The function does <strong>not</strong> verify that the type of <code>v</code> matches the underlying input ndarray data type, and, thus, overwriting <strong>unowned</strong> memory is possible. The function <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
</ul>
<h4 id="stdlib_ndarray_set_complex64-arr-sub-v-">stdlib_ndarray_set_complex64( *arr, *sub, v )</h4>
<p>Sets a single-precision complex floating-point ndarray data element.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_set_complex64</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub, <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> <span class="hljs-built_in">complex</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t*</code> ndarray subscripts.</li>
<li><strong>v</strong>: <code>[in] float complex</code> value to set.</li>
</ul>
<p>Notes</p>
<ul>
<li>The function does <strong>not</strong> verify that the type of <code>v</code> matches the underlying input ndarray data type, and, thus, overwriting <strong>unowned</strong> memory is possible. The function <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
</ul>
<h4 id="stdlib_ndarray_set_bool-arr-sub-v-">stdlib_ndarray_set_bool( *arr, *sub, v )</h4>
<p>Sets a boolean ndarray data element.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_set_bool</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> *sub, <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>sub</strong>: <code>[in] int64_t*</code> ndarray subscripts.</li>
<li><strong>v</strong>: <code>[in] bool</code> value to set.</li>
</ul>
<p>Notes</p>
<ul>
<li>The function does <strong>not</strong> verify that the type of <code>v</code> matches the underlying input ndarray data type, and, thus, overwriting <strong>unowned</strong> memory is possible. The function <strong>assumes</strong> that you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
</ul>
<hr>
<h4 id="stdlib_ndarray_set_ptr_value-arr-idx-v-">stdlib_ndarray_set_ptr_value( *arr, *idx, *v )</h4>
<p>Sets an ndarray data element specified by a byte array pointer.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_set_ptr_value</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *arr, <span class="hljs-keyword">uint8_t</span> *idx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>arr</strong>: <code>[in] struct ndarray*</code> input ndarray.</li>
<li><strong>idx</strong>: <code>[in] uint8_t*</code> byte array pointer to an ndarray data element.</li>
<li><strong>v</strong>: <code>[in] void*</code> value to set.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function does <strong>not</strong> perform bounds checking, and, thus, the function does <strong>not</strong> prevent you from overwriting <strong>unowned</strong> memory. Accordingly, the function <strong>assumes</strong> you know what you are doing.</li>
<li>The function returns <code>-1</code> if unable to set an element and <code>0</code> otherwise.</li>
<li>The function requires a pointer to a data value <code>v</code> in order to provide a generic API supporting ndarrays having different data types.</li>
</ul>
<h4 id="stdlib_ndarray_set_ptr_float64-idx-v-">stdlib_ndarray_set_ptr_float64( *idx, v )</h4>
<p>Sets a double-precision floating-point ndarray data element specified by a byte array pointer.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_set_ptr_float64</span><span class="hljs-params">( <span class="hljs-keyword">uint8_t</span> *idx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>idx</strong>: <code>[in] uint8_t*</code> byte array pointer to an ndarray data element.</li>
<li><strong>v</strong>: <code>[in] double</code> value to set.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function has no way of determining whether <code>idx</code> actually points to a compatible memory address. Accordingly, overwriting <strong>unowned</strong> memory is possible, and this function <strong>assumes</strong> you know what you are doing.</li>
<li>The function always returns <code>0</code>.</li>
</ul>
<h4 id="stdlib_ndarray_set_ptr_float32-idx-v-">stdlib_ndarray_set_ptr_float32( *idx, v )</h4>
<p>Sets a single-precision floating-point ndarray data element specified by a byte array pointer.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_set_ptr_float32</span><span class="hljs-params">( <span class="hljs-keyword">uint8_t</span> *idx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>idx</strong>: <code>[in] uint8_t*</code> byte array pointer to an ndarray data element.</li>
<li><strong>v</strong>: <code>[in] float</code> value to set.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function has no way of determining whether <code>idx</code> actually points to a compatible memory address. Accordingly, overwriting <strong>unowned</strong> memory is possible, and this function <strong>assumes</strong> you know what you are doing.</li>
<li>The function always returns <code>0</code>.</li>
</ul>
<h4 id="stdlib_ndarray_set_ptr_uint64-idx-v-">stdlib_ndarray_set_ptr_uint64( *idx, v )</h4>
<p>Sets an unsigned 64-bit integer ndarray data element specified by a byte array pointer.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_set_ptr_uint64</span><span class="hljs-params">( <span class="hljs-keyword">uint8_t</span> *idx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint64_t</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>idx</strong>: <code>[in] uint8_t*</code> byte array pointer to an ndarray data element.</li>
<li><strong>v</strong>: <code>[in] uint64_t</code> value to set.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function has no way of determining whether <code>idx</code> actually points to a compatible memory address. Accordingly, overwriting <strong>unowned</strong> memory is possible, and this function <strong>assumes</strong> you know what you are doing.</li>
<li>The function always returns <code>0</code>.</li>
</ul>
<h4 id="stdlib_ndarray_set_ptr_int64-idx-v-">stdlib_ndarray_set_ptr_int64( *idx, v )</h4>
<p>Sets a signed 64-bit integer ndarray data element specified by a byte array pointer.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_set_ptr_int64</span><span class="hljs-params">( <span class="hljs-keyword">uint8_t</span> *idx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>idx</strong>: <code>[in] uint8_t*</code> byte array pointer to an ndarray data element.</li>
<li><strong>v</strong>: <code>[in] int64_t</code> value to set.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function has no way of determining whether <code>idx</code> actually points to a compatible memory address. Accordingly, overwriting <strong>unowned</strong> memory is possible, and this function <strong>assumes</strong> you know what you are doing.</li>
<li>The function always returns <code>0</code>.</li>
</ul>
<h4 id="stdlib_ndarray_set_ptr_uint32-idx-v-">stdlib_ndarray_set_ptr_uint32( *idx, v )</h4>
<p>Sets an unsigned 32-bit integer ndarray data element specified by a byte array pointer.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_set_ptr_uint32</span><span class="hljs-params">( <span class="hljs-keyword">uint8_t</span> *idx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>idx</strong>: <code>[in] uint8_t*</code> byte array pointer to an ndarray data element.</li>
<li><strong>v</strong>: <code>[in] uint32_t</code> value to set.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function has no way of determining whether <code>idx</code> actually points to a compatible memory address. Accordingly, overwriting <strong>unowned</strong> memory is possible, and this function <strong>assumes</strong> you know what you are doing.</li>
<li>The function always returns <code>0</code>.</li>
</ul>
<h4 id="stdlib_ndarray_set_ptr_int32-idx-v-">stdlib_ndarray_set_ptr_int32( *idx, v )</h4>
<p>Sets a signed 32-bit integer ndarray data element specified by a byte array pointer.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_set_ptr_int32</span><span class="hljs-params">( <span class="hljs-keyword">uint8_t</span> *idx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int32_t</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>idx</strong>: <code>[in] uint8_t*</code> byte array pointer to an ndarray data element.</li>
<li><strong>v</strong>: <code>[in] int32_t</code> value to set.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function has no way of determining whether <code>idx</code> actually points to a compatible memory address. Accordingly, overwriting <strong>unowned</strong> memory is possible, and this function <strong>assumes</strong> you know what you are doing.</li>
<li>The function always returns <code>0</code>.</li>
</ul>
<h4 id="stdlib_ndarray_set_ptr_uint16-idx-v-">stdlib_ndarray_set_ptr_uint16( *idx, v )</h4>
<p>Sets an unsigned 16-bit integer ndarray data element specified by a byte array pointer.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_set_ptr_uint16</span><span class="hljs-params">( <span class="hljs-keyword">uint8_t</span> *idx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint16_t</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>idx</strong>: <code>[in] uint8_t*</code> byte array pointer to an ndarray data element.</li>
<li><strong>v</strong>: <code>[in] uint16_t</code> value to set.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function has no way of determining whether <code>idx</code> actually points to a compatible memory address. Accordingly, overwriting <strong>unowned</strong> memory is possible, and this function <strong>assumes</strong> you know what you are doing.</li>
<li>The function always returns <code>0</code>.</li>
</ul>
<h4 id="stdlib_ndarray_set_ptr_int16-idx-v-">stdlib_ndarray_set_ptr_int16( *idx, v )</h4>
<p>Sets a signed 16-bit integer ndarray data element specified by a byte array pointer.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_set_ptr_int16</span><span class="hljs-params">( <span class="hljs-keyword">uint8_t</span> *idx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int16_t</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>idx</strong>: <code>[in] uint8_t*</code> byte array pointer to an ndarray data element.</li>
<li><strong>v</strong>: <code>[in] int16_t</code> value to set.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function has no way of determining whether <code>idx</code> actually points to a compatible memory address. Accordingly, overwriting <strong>unowned</strong> memory is possible, and this function <strong>assumes</strong> you know what you are doing.</li>
<li>The function always returns <code>0</code>.</li>
</ul>
<h4 id="stdlib_ndarray_set_ptr_uint8-idx-v-">stdlib_ndarray_set_ptr_uint8( *idx, v )</h4>
<p>Sets an unsigned 8-bit integer ndarray data element specified by a byte array pointer.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_set_ptr_uint8</span><span class="hljs-params">( <span class="hljs-keyword">uint8_t</span> *idx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>idx</strong>: <code>[in] uint8_t*</code> byte array pointer to an ndarray data element.</li>
<li><strong>v</strong>: <code>[in] uint8_t</code> value to set.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function always returns <code>0</code>.</li>
</ul>
<h4 id="stdlib_ndarray_set_ptr_int8-idx-v-">stdlib_ndarray_set_ptr_int8( *idx, v )</h4>
<p>Sets a signed 8-bit integer ndarray data element specified by a byte array pointer.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_set_ptr_int8</span><span class="hljs-params">( <span class="hljs-keyword">uint8_t</span> *idx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int8_t</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>idx</strong>: <code>[in] uint8_t*</code> byte array pointer to an ndarray data element.</li>
<li><strong>v</strong>: <code>[in] int8_t</code> value to set.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function always returns <code>0</code>.</li>
</ul>
<h4 id="stdlib_ndarray_set_ptr_complex128-idx-v-">stdlib_ndarray_set_ptr_complex128( *idx, v )</h4>
<p>Sets a double-precision complex floating-point ndarray data element specified by a byte array pointer.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_set_ptr_complex128</span><span class="hljs-params">( <span class="hljs-keyword">uint8_t</span> *idx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> <span class="hljs-built_in">complex</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>idx</strong>: <code>[in] uint8_t*</code> byte array pointer to an ndarray data element.</li>
<li><strong>v</strong>: <code>[in] double complex</code> value to set.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function has no way of determining whether <code>idx</code> actually points to a compatible memory address. Accordingly, overwriting <strong>unowned</strong> memory is possible, and this function <strong>assumes</strong> you know what you are doing.</li>
<li>The function always returns <code>0</code>.</li>
</ul>
<h4 id="stdlib_ndarray_set_ptr_complex64-idx-v-">stdlib_ndarray_set_ptr_complex64( *idx, v )</h4>
<p>Sets a single-precision complex floating-point ndarray data element specified by a byte array pointer.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_set_ptr_complex64</span><span class="hljs-params">( <span class="hljs-keyword">uint8_t</span> *idx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> <span class="hljs-built_in">complex</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>idx</strong>: <code>[in] uint8_t*</code> byte array pointer to an ndarray data element.</li>
<li><strong>v</strong>: <code>[in] float complex</code> value to set.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function has no way of determining whether <code>idx</code> actually points to a compatible memory address. Accordingly, overwriting <strong>unowned</strong> memory is possible, and this function <strong>assumes</strong> you know what you are doing.</li>
<li>The function always returns <code>0</code>.</li>
</ul>
<h4 id="stdlib_ndarray_set_ptr_bool-idx-v-">stdlib_ndarray_set_ptr_bool( *idx, v )</h4>
<p>Sets a boolean ndarray data element specified by a byte array pointer.</p>
<pre><code class="hljs language-c"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">stdlib_ndarray_set_ptr_bool</span><span class="hljs-params">( <span class="hljs-keyword">uint8_t</span> *idx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> v )</span></span>;
</code></pre>
<p>The function accepts the following arguments:</p>
<ul>
<li><strong>idx</strong>: <code>[in] uint8_t*</code> byte array pointer to an ndarray data element.</li>
<li><strong>v</strong>: <code>[in] bool</code> value to set.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The function has no way of determining whether <code>idx</code> actually points to a compatible memory address. Accordingly, overwriting <strong>unowned</strong> memory is possible, and this function <strong>assumes</strong> you know what you are doing.</li>
<li>The function always returns <code>0</code>.</li>
</ul>
</section>
<!-- /.usage -->
<!-- C API usage notes. Make sure to keep an empty line after the `section` element and another before the `/section` close. -->
<section class="notes">
</section>
<!-- /.notes -->
<!-- C API usage examples. -->
<hr>
<section class="examples">
<h3 id="examples-1">Examples</h3>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/ctor.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/dtypes.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/index_modes.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/orders.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/base/bytes_per_element.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdlib/ndarray/base/dtype_char.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdlib.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdio.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;stdint.h></span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&#x3C;inttypes.h></span></span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_ndarray_contents</span><span class="hljs-params">( <span class="hljs-keyword">const</span> struct ndarray *x )</span> </span>{
    <span class="hljs-keyword">int64_t</span> i;
    <span class="hljs-keyword">double</span> v;
    <span class="hljs-keyword">int8_t</span> s;

    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &#x3C; stdlib_ndarray_length( x ); i++ ) {
        s = stdlib_ndarray_iget_float64( x, i, &#x26;v ); <span class="hljs-comment">// WARNING: assumes `x->dtype` is float64</span>
        <span class="hljs-keyword">if</span> ( s != <span class="hljs-number">0</span> ) {
            <span class="hljs-built_in">printf</span>( <span class="hljs-string">"Unable to resolve data element.\n"</span> );
            <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
        }
        <span class="hljs-built_in">printf</span>( <span class="hljs-string">"data[%"</span>PRId64<span class="hljs-string">"] = %f\n"</span>, i, v );
    }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Manually create an ndarray (WARNING: this is for illustration purposes only, as the fields of an ndarray are subject to change; for ABI compatibility, use utility functions for accessing ndarray data)...</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ndarray</span> *<span class="hljs-title">x1</span> =</span> <span class="hljs-built_in">malloc</span>( <span class="hljs-keyword">sizeof</span>( struct ndarray ) );
    <span class="hljs-keyword">if</span> ( x1 == <span class="hljs-literal">NULL</span> ) {
        <span class="hljs-built_in">printf</span>( <span class="hljs-string">"Error allocating memory.\n"</span> );
        <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
    }

    <span class="hljs-comment">// Specify the underlying data type:</span>
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">STDLIB_NDARRAY_DTYPE</span> <span class="hljs-title">dtype</span> =</span> STDLIB_NDARRAY_FLOAT64;
    x1->dtype = dtype;

    <span class="hljs-comment">// Create an underlying byte array:</span>
    <span class="hljs-keyword">uint8_t</span> buffer[] = { <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> };
    x1->data = buffer;

    <span class="hljs-comment">// Explicitly specify the number of bytes per element:</span>
    x1->BYTES_PER_ELEMENT = STDLIB_NDARRAY_FLOAT64_BYTES_PER_ELEMENT;

    <span class="hljs-comment">// Specify the array shape:</span>
    <span class="hljs-keyword">int64_t</span> shape[] = { <span class="hljs-number">3</span> }; <span class="hljs-comment">// vector consisting of 3 doubles</span>
    x1->shape = shape;

    <span class="hljs-comment">// Specify the array strides:</span>
    <span class="hljs-keyword">int64_t</span> strides[] = { x1->BYTES_PER_ELEMENT };
    x1->strides = strides;

    <span class="hljs-comment">// Specify the byte offset:</span>
    x1->offset = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Specify the array order (note: this does not matter for a 1-dimensional array):</span>
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">STDLIB_NDARRAY_ORDER</span> <span class="hljs-title">order</span> =</span> STDLIB_NDARRAY_ROW_MAJOR;
    x1->order = order;

    <span class="hljs-comment">// Specify the index mode:</span>
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">STDLIB_NDARRAY_INDEX_MODE</span> <span class="hljs-title">imode</span> =</span> STDLIB_NDARRAY_INDEX_ERROR;
    x1->imode = imode;

    <span class="hljs-comment">// Specify the subscript index modes:</span>
    <span class="hljs-keyword">int8_t</span> submodes[] = { imode };
    x1->submodes = submodes;
    x1->nsubmodes = <span class="hljs-number">1</span>;

    <span class="hljs-comment">// Explicitly specify the number of array dimensions:</span>
    x1->ndims = <span class="hljs-number">1</span>; <span class="hljs-comment">// vector</span>

    <span class="hljs-comment">// Explicitly specify the number of array elements (doubles):</span>
    x1->length = x1->shape[ <span class="hljs-number">0</span> ];

    <span class="hljs-comment">// Explicitly specify the number of bytes:</span>
    x1->byteLength = (x1->length) * (x1->BYTES_PER_ELEMENT);

    <span class="hljs-comment">// Explicitly set the array flags:</span>
    x1->flags = stdlib_ndarray_flags( x1 );

    <span class="hljs-built_in">printf</span>( <span class="hljs-string">"dtype = %u\n"</span>, stdlib_ndarray_dtype( x1 ) );
    <span class="hljs-built_in">printf</span>( <span class="hljs-string">"length = %"</span>PRId64<span class="hljs-string">"\n"</span>, stdlib_ndarray_length( x1 ) );
    <span class="hljs-built_in">printf</span>( <span class="hljs-string">"byteLength = %"</span>PRId64<span class="hljs-string">"\n"</span>, stdlib_ndarray_bytelength( x1 ) );
    <span class="hljs-built_in">printf</span>( <span class="hljs-string">"ltr = %u\n"</span>, stdlib_ndarray_dtype_char( stdlib_ndarray_dtype( x1 ) ) );
    <span class="hljs-built_in">printf</span>( <span class="hljs-string">"\n"</span> );

    <span class="hljs-comment">// Use the function interface to create an ndarray (<span class="hljs-doctag">NOTE:</span> for future ABI compatibility, using the following function interface should be preferred)...</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ndarray</span> *<span class="hljs-title">x2</span> =</span> stdlib_ndarray_allocate( dtype, buffer, <span class="hljs-number">1</span>, shape, strides, <span class="hljs-number">0</span>, order, imode, <span class="hljs-number">1</span>, submodes );
    <span class="hljs-keyword">if</span> ( x2 == <span class="hljs-literal">NULL</span> ) {
        <span class="hljs-built_in">printf</span>( <span class="hljs-string">"Error allocating memory.\n"</span> );
        <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
    }

    <span class="hljs-built_in">printf</span>( <span class="hljs-string">"dtype = %u\n"</span>, stdlib_ndarray_dtype( x2 ) );
    <span class="hljs-built_in">printf</span>( <span class="hljs-string">"length = %"</span>PRId64<span class="hljs-string">"\n"</span>, stdlib_ndarray_length( x2 ) );
    <span class="hljs-built_in">printf</span>( <span class="hljs-string">"byteLength = %"</span>PRId64<span class="hljs-string">"\n"</span>, stdlib_ndarray_bytelength( x2 ) );
    <span class="hljs-built_in">printf</span>( <span class="hljs-string">"ltr = %u\n"</span>, stdlib_ndarray_dtype_char( stdlib_ndarray_dtype( x2 ) ) );
    <span class="hljs-built_in">printf</span>( <span class="hljs-string">"\n"</span> );

    <span class="hljs-comment">// Set values in the underlying byte array using pointers:</span>
    <span class="hljs-keyword">int64_t</span> sub[] = { <span class="hljs-number">0</span> };
    <span class="hljs-keyword">uint8_t</span> *ptr = stdlib_ndarray_get_ptr( x2, sub );
    <span class="hljs-keyword">if</span> ( ptr == <span class="hljs-literal">NULL</span> ) {
        <span class="hljs-built_in">printf</span>( <span class="hljs-string">"Unable to resolve data pointer.\n"</span> );
        <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
    }
    *(<span class="hljs-keyword">double</span> *)ptr = <span class="hljs-number">1.0</span>;

    sub[ <span class="hljs-number">0</span> ] = <span class="hljs-number">1</span>;
    ptr = stdlib_ndarray_get_ptr( x2, sub );
    <span class="hljs-keyword">if</span> ( ptr == <span class="hljs-literal">NULL</span> ) {
        <span class="hljs-built_in">printf</span>( <span class="hljs-string">"Unable to resolve data pointer.\n"</span> );
        <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
    }
    *(<span class="hljs-keyword">double</span> *)ptr = <span class="hljs-number">2.0</span>;

    sub[ <span class="hljs-number">0</span> ] = <span class="hljs-number">2</span>;
    ptr = stdlib_ndarray_get_ptr( x2, sub );
    <span class="hljs-keyword">if</span> ( ptr == <span class="hljs-literal">NULL</span> ) {
        <span class="hljs-built_in">printf</span>( <span class="hljs-string">"Unable to resolve data pointer.\n"</span> );
        <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
    }
    *(<span class="hljs-keyword">double</span> *)ptr = <span class="hljs-number">3.0</span>;

    <span class="hljs-comment">// Print out the current ndarray elements:</span>
    print_ndarray_contents( x2 );
    <span class="hljs-built_in">printf</span>( <span class="hljs-string">"\n"</span> );

    <span class="hljs-comment">// Set values in the underlying byte array using a "generic" function:</span>
    sub[ <span class="hljs-number">0</span> ] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">double</span> v = <span class="hljs-number">4.0</span>;
    <span class="hljs-keyword">int8_t</span> status = stdlib_ndarray_set( x2, sub, (<span class="hljs-keyword">void</span> *)&#x26;v );
    <span class="hljs-keyword">if</span> ( status != <span class="hljs-number">0</span> ) {
        <span class="hljs-built_in">printf</span>( <span class="hljs-string">"Unable to set data element.\n"</span> );
        <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
    }

    sub[ <span class="hljs-number">0</span> ] = <span class="hljs-number">1</span>;
    v = <span class="hljs-number">5.0</span>;
    status = stdlib_ndarray_set( x2, sub, (<span class="hljs-keyword">void</span> *)&#x26;v );
    <span class="hljs-keyword">if</span> ( status != <span class="hljs-number">0</span> ) {
        <span class="hljs-built_in">printf</span>( <span class="hljs-string">"Unable to set data element.\n"</span> );
        <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
    }

    sub[ <span class="hljs-number">0</span> ] = <span class="hljs-number">2</span>;
    v = <span class="hljs-number">6.0</span>;
    status = stdlib_ndarray_set( x2, sub, (<span class="hljs-keyword">void</span> *)&#x26;v );
    <span class="hljs-keyword">if</span> ( status != <span class="hljs-number">0</span> ) {
        <span class="hljs-built_in">printf</span>( <span class="hljs-string">"Unable to set data element.\n"</span> );
        <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
    }

    <span class="hljs-comment">// Print out the current ndarray elements:</span>
    print_ndarray_contents( x2 );
    <span class="hljs-built_in">printf</span>( <span class="hljs-string">"\n"</span> );

    <span class="hljs-comment">// Set values in the underlying byte array using a specialized function:</span>
    sub[ <span class="hljs-number">0</span> ] = <span class="hljs-number">0</span>;
    status = stdlib_ndarray_set_float64( x2, sub, <span class="hljs-number">7.0</span> );
    <span class="hljs-keyword">if</span> ( status != <span class="hljs-number">0</span> ) {
        <span class="hljs-built_in">printf</span>( <span class="hljs-string">"Unable to set data element.\n"</span> );
        <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
    }

    sub[ <span class="hljs-number">0</span> ] = <span class="hljs-number">1</span>;
    status = stdlib_ndarray_set_float64( x2, sub, <span class="hljs-number">8.0</span> );
    <span class="hljs-keyword">if</span> ( status != <span class="hljs-number">0</span> ) {
        <span class="hljs-built_in">printf</span>( <span class="hljs-string">"Unable to set data element.\n"</span> );
        <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
    }

    sub[ <span class="hljs-number">0</span> ] = <span class="hljs-number">2</span>;
    status = stdlib_ndarray_set_float64( x2, sub, <span class="hljs-number">9.0</span> );
    <span class="hljs-keyword">if</span> ( status != <span class="hljs-number">0</span> ) {
        <span class="hljs-built_in">printf</span>( <span class="hljs-string">"Unable to set data element.\n"</span> );
        <span class="hljs-built_in">exit</span>( <span class="hljs-number">1</span> );
    }

    <span class="hljs-comment">// Print out the current ndarray elements:</span>
    print_ndarray_contents( x2 );
    <span class="hljs-built_in">printf</span>( <span class="hljs-string">"\n"</span> );

    <span class="hljs-comment">// Free allocated memory:</span>
    stdlib_ndarray_free( x1 );
    stdlib_ndarray_free( x2 );
}
</code></pre>
</section>
<!-- /.examples -->
</section>
<!-- /.c -->
<!-- Section to include cited references. If references are included, add a horizontal rule *before* the section. Make sure to keep an empty line after the `section` element and another before the `/section` close. -->
<section class="references">
</section>
<!-- /.references -->
<!-- Section for related `stdlib` packages. Do not manually edit this section, as it is automatically populated. -->
<section class="related">
<hr>
<h2 id="see-also">See Also</h2>
<ul>
<li><span class="package-name"><a href="/docs/api/latest/@stdlib/ndarray/array"><code>@stdlib/ndarray/array</code></a></span><span class="delimiter">: </span><span class="description">multidimensional arrays.</span></li>
</ul>
</section>
<!-- /.related -->
<!-- Section for all links. Make sure to keep an empty line after the `section` element and another before the `/section` close. -->
<section class="links">
<!-- <related-links> -->
<!-- </related-links> -->
</section>
<!-- /.links -->
