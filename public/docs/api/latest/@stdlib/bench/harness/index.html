<h1 id="benchmark">Benchmark</h1><blockquote><p>Benchmark harness.</p></blockquote><section class="intro"></section><section class="usage"><h2 id="usage">Usage</h2><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> bench = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/bench/harness'</span> );
</code></pre><p><a name="bench"></a></p><h4 id="bench-name-options-benchmark-">bench( name[, options][, benchmark] )</h4><p>Queues a <code>benchmark</code> to be run during a subsequent turn of the event loop. After running the <code>benchmark</code>, the function outputs benchmark results as Test Anything Protocol (<a href="https://testanything.org/tap-version-13-specification.html">TAP</a>) output.</p><pre><code class="hljs language-javascript">bench( <span class="hljs-string">'Math.sin'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">benchmark</span>(<span class="hljs-params"> b </span>) </span>{
    <span class="hljs-keyword">var</span> x;
    <span class="hljs-keyword">var</span> i;
    b.tic();
    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &#x3C; b.iterations; i++ ) {
        x = <span class="hljs-built_in">Math</span>.sin( <span class="hljs-built_in">Math</span>.random() );
        <span class="hljs-keyword">if</span> ( x !== x ) {
            b.fail( <span class="hljs-string">'should not return NaN'</span> );
        }
    }
    b.toc();
    <span class="hljs-keyword">if</span> ( x !== x ) {
        b.fail( <span class="hljs-string">'should not return NaN'</span> );
    }
    b.pass( <span class="hljs-string">'benchmark finished'</span> );
    b.end();
});
</code></pre><p>A <code>benchmark</code> function has the following signature:</p><pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">benchmark</span>(<span class="hljs-params"> b </span>) </span>{
    <span class="hljs-comment">// Benchmark code...</span>
}
</code></pre><p>where <code>b</code> is a <code>Benchmark</code> instance. Synchronous benchmarks should, at minimum, have the following structure:</p><pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">benchmark</span>(<span class="hljs-params"> b </span>) </span>{
    <span class="hljs-keyword">var</span> x;
    <span class="hljs-keyword">var</span> i;

    <span class="hljs-comment">// [1] Start timing:</span>
    b.tic();

    <span class="hljs-comment">// [2] Loop containing code to time...</span>
    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &#x3C; b.iterations; i++ ) {
        <span class="hljs-comment">// [3] Code to time...</span>

        <span class="hljs-comment">// [4] A conditional verifying results to prevent certain compiler optimizations:</span>
        <span class="hljs-keyword">if</span> ( x !== x ) {
            b.fail( <span class="hljs-string">'something went wrong!'</span> );
        }
    }
    <span class="hljs-comment">// [5] Stop timing:</span>
    b.toc();

    <span class="hljs-comment">// [6] Another conditional verifying results to prevent certain compiler optimizations:</span>
    <span class="hljs-keyword">if</span> ( x !== x ) {
        b.fail( <span class="hljs-string">'something went wrong!'</span> );
    }
    <span class="hljs-comment">// [7] End the benchmark:</span>
    b.end();
}
</code></pre><p>Asynchronous benchmarks should have a structure similar to the following:</p><pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">benchmark</span>(<span class="hljs-params"> b </span>) </span>{
    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// [1] Start timing:</span>
    b.tic();

    <span class="hljs-comment">// [2] Asynchronous code to time:</span>
    <span class="hljs-keyword">return</span> next();

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span>(<span class="hljs-params"> error </span>) </span>{
        <span class="hljs-keyword">if</span> ( error ) {
            <span class="hljs-keyword">return</span> b.fail( error.message );
        }
        i += <span class="hljs-number">1</span>;

        <span class="hljs-comment">// [3] Exit condition:</span>
        <span class="hljs-keyword">if</span> ( i &#x3C;= b.iterations ) {
            <span class="hljs-comment">// Asynchronous task...</span>
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-comment">// [4] Stop timing:</span>
        b.toc();

        <span class="hljs-comment">// [5] End the benchmark:</span>
        b.end();
    }
}
</code></pre><p>For both synchronous and asynchronous benchmarks, calling <code>b.end()</code> is <strong>mandatory</strong>, as failing to do so will cause the harness to hang. For example, the following benchmark will <strong>never</strong> complete.</p><pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">benchmark</span>(<span class="hljs-params"> b </span>) </span>{
    <span class="hljs-keyword">var</span> i;
    b.tic();
    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &#x3C; b.iterations; i++ ) {
        <span class="hljs-comment">// Synchronous task...</span>
    }
    b.toc();
}
</code></pre><p><strong>Avoid</strong> making assertions within timed code, as doing so will <strong>significantly</strong> affect raw performance numbers. For example, <strong>avoid</strong> the following:</p><pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">benchmark</span>(<span class="hljs-params"> b </span>) </span>{
    <span class="hljs-keyword">var</span> x;
    <span class="hljs-keyword">var</span> i;
    b.tic();
    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &#x3C; b.iterations; i++ ) {
        x = <span class="hljs-built_in">Math</span>.sin( <span class="hljs-built_in">Math</span>.random() );
        b.equal( x, x, <span class="hljs-string">'does not return NaN'</span> ); <span class="hljs-comment">// Avoid doing this!</span>
    }
    b.toc();
    b.equal( x, x, <span class="hljs-string">'does not return NaN'</span> );     <span class="hljs-comment">// This is fine.</span>
    b.end();
}
</code></pre><p>Additionally, ensure that all setup code executes <strong>before</strong> calling <code>b.tic()</code> and that all cleanup code executes <strong>after</strong> calling <code>b.toc()</code>. For example, <strong>avoid</strong> the following:</p><pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">benchmark</span>(<span class="hljs-params"> b </span>) </span>{
    <span class="hljs-keyword">var</span> x;
    <span class="hljs-keyword">var</span> y;
    <span class="hljs-keyword">var</span> i;

    <span class="hljs-comment">// Start timing:</span>
    b.tic();

    <span class="hljs-comment">// Setup code:</span>
    x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>( b.iterations );                  <span class="hljs-comment">// Should be before b.tic()!</span>
    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &#x3C; b.iterations; i++ ) {
        x[ i ] = <span class="hljs-built_in">Math</span>.random();
    }
    <span class="hljs-comment">// Code to be timed...</span>
    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &#x3C; b.iterations; i++ ) {
        y = <span class="hljs-built_in">Math</span>.sin( x[ i ] );
        <span class="hljs-keyword">if</span> ( y !== y ) {
            b.fail( <span class="hljs-string">'should not return NaN'</span> );
        }
    }
    <span class="hljs-comment">// Verify results:</span>
    b.equal( x, x, <span class="hljs-string">'does not return NaN'</span> );         <span class="hljs-comment">// Should be after b.toc()!</span>

    <span class="hljs-comment">// Stop timing:</span>
    b.toc();

    b.end();
}
</code></pre><p>The function accepts the following <code>options</code>:</p><ul><li><strong>iterations</strong>: number of iterations. If <code>null</code>, the number of iterations is determined by trying successive powers of <code>10</code> until the total time is at least <code>0.1</code> seconds. Default: <code>null</code>.</li><li><strong>repeats</strong>: number of repeats. Default: <code>3</code>.</li><li><strong>timeout</strong>: number of milliseconds before a benchmark is considered failed. Exceeding a timeout does <strong>not</strong>, however, end the benchmark. Ending a long running benchmark requires manual intervention. Default: <code>300000</code> (5 minutes).</li><li><strong>skip</strong>: <code>boolean</code> indicating whether to skip a benchmark.</li></ul><p>By default, the harness will automatically determine an iteration number for each benchmark such that a benchmark runs for a length of time sufficient to accurately compute benchmark results. To require a specific number of iterations, set the <code>iterations</code> option.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> opts = {
    <span class="hljs-string">'iterations'</span>: <span class="hljs-number">1e6</span>
};

bench( <span class="hljs-string">'require a specific number of iterations'</span>, opts, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">benchmark</span>(<span class="hljs-params"> b </span>) </span>{
    <span class="hljs-keyword">var</span> i;
    b.tic();
    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &#x3C; b.iterations; i++ ) {
        <span class="hljs-comment">// Code to be benchmarked...</span>
    }
    b.toc();
    b.end();
});
</code></pre><p>To ensure that benchmark results are reproducible, the harness runs each benchmark function multiple times. To specify a repetition number, set the <code>repeats</code> option.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> opts = {
    <span class="hljs-string">'repeats'</span>: <span class="hljs-number">5</span>
};

bench( <span class="hljs-string">'repeat a benchmark multiple times'</span>, opts, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">benchmark</span>(<span class="hljs-params"> b </span>) </span>{
    <span class="hljs-keyword">var</span> i;
    b.tic();
    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &#x3C; b.iterations; i++ ) {
        <span class="hljs-comment">// Code to be benchmarked...</span>
    }
    b.toc();
    b.end();
});
</code></pre><p>To skip a benchmark, set the <code>skip</code> option.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> opts = {
    <span class="hljs-string">'skip'</span>: <span class="hljs-literal">true</span>
};

bench( <span class="hljs-string">'skipped benchmark'</span>, opts, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">benchmark</span>(<span class="hljs-params"> b </span>) </span>{
    <span class="hljs-keyword">var</span> i;
    b.tic();
    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &#x3C; b.iterations; i++ ) {
        <span class="hljs-comment">// Code to be benchmarked...</span>
    }
    b.toc();
    b.end();
});
</code></pre><p>To fail benchmarks which take longer than a specified amount of time to complete, set a <code>timeout</code> option (in milliseconds).</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> opts = {
    <span class="hljs-string">'timeout'</span>: <span class="hljs-number">5000</span>    <span class="hljs-comment">// 5 seconds</span>
};

bench( <span class="hljs-string">'async benchmark'</span>, opts, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">benchmark</span>(<span class="hljs-params"> b </span>) </span>{
    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;
    b.tic();
    <span class="hljs-keyword">return</span> next();

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span>(<span class="hljs-params"> error </span>) </span>{
        <span class="hljs-keyword">if</span> ( error ) {
            <span class="hljs-keyword">return</span> b.fail( error.message );
        }
        i += <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> ( i &#x3C;= b.iterations ) {
            <span class="hljs-comment">// Asynchronous task...</span>
            <span class="hljs-keyword">return</span>;
        }
        b.toc();
        b.end();
    }
});
</code></pre><p><a name="bench-onfinish"></a></p><h4 id="benchonfinish-clbk-">bench.onFinish( clbk )</h4><p>Sets a listener which is invoked once the harness <strong>finishes</strong> running all benchmarks.</p><pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onFinish</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">'Done!'</span> );
}

bench.onFinish( onFinish );
</code></pre><p><a name="bench-createstream"></a></p><h4 id="benchcreatestream-options-">bench.createStream( [options] )</h4><p>Returns a results <a href="https://nodejs.org/api/stream.html">stream</a>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> stdout = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/streams/node/stdout'</span> );

<span class="hljs-keyword">var</span> stream = bench.createStream();

<span class="hljs-comment">// Direct all results to `stdout`:</span>
stream.pipe( stdout );

<span class="hljs-keyword">var</span> opts = {
    <span class="hljs-string">'iterations'</span>: <span class="hljs-number">1</span>,
    <span class="hljs-string">'repeats'</span>: <span class="hljs-number">1</span>
};

bench( <span class="hljs-string">'beep'</span>, opts, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">benchmark</span>(<span class="hljs-params"> b </span>) </span>{
    <span class="hljs-keyword">var</span> i;
    b.tic();
    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &#x3C; b.iterations; i++ ) {
        b.equal( <span class="hljs-number">3.14</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">'should be equal'</span> );
    }
    b.toc();
    b.end();
});
</code></pre><pre><code class="no-highlight language-text">TAP version 13
# beep
ok 1 should be equal
  ---
  iterations: 1
  elapsed: 0.002985193
  rate: 334.98671610177297
  ...
#
1..1
# total 1
# pass  1
#
# ok
</code></pre><p>The results stream can be combined with any <a href="https://nodejs.org/api/stream.html#stream_writable_streams"><code>Writable</code></a> stream (e.g., network connection, file, <code>stdout</code>, etc).</p><p>The function accepts the same <code>options</code> as <a href="/docs/api/latest/@stdlib/streams/node/transform">@stdlib/streams/node/transform</a>. For example, by default, the method returns a stream which produces <a href="https://testanything.org/tap-version-13-specification.html">TAP</a> output as text. To return an object stream,</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> opts = {
    <span class="hljs-string">'objectMode'</span>: <span class="hljs-literal">true</span>
};

<span class="hljs-keyword">var</span> stream = bench.createStream( opts );
stream.on( <span class="hljs-string">'data'</span>, onRow );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onRow</span>(<span class="hljs-params"> row </span>) </span>{
    <span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">JSON</span>.stringify( row ) );
}

opts = {
    <span class="hljs-string">'iterations'</span>: <span class="hljs-number">1</span>,
    <span class="hljs-string">'repeats'</span>: <span class="hljs-number">1</span>
};

bench( <span class="hljs-string">'beep'</span>, opts, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">benchmark</span>(<span class="hljs-params"> b </span>) </span>{
    <span class="hljs-keyword">var</span> i;
    b.tic();
    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &#x3C; b.iterations; i++ ) {
        b.equal( <span class="hljs-number">3.14</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">'should be equal'</span> );
    }
    b.toc();
    b.end();
});
</code></pre><pre><code class="no-highlight language-text">{"type":"benchmark","name":"beep","id":0}
{"id":0,"ok":true,"name":"should be equal","operator":"equal","actual":3.14,"expected":3.14,"benchmark":0,"type":"assert"}
{"ok":true,"operator":"result","iterations":1,"elapsed":0.00283753,"rate":352.41918147120913,"benchmark":0,"type":"result"}
{"benchmark":0,"type":"end"}
</code></pre><p><a name="bench-createharness"></a></p><h4 id="benchcreateharness-options-clbk-">bench.createHarness( [options][, clbk] )</h4><p>Creates a benchmark harness with a new pending stack and state.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> harness = bench.createHarness();

harness( <span class="hljs-string">'beep'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">benchmark</span>(<span class="hljs-params"> b </span>) </span>{
    <span class="hljs-keyword">var</span> i;
    b.tic();
    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &#x3C; b.iterations; i++ ) {
        <span class="hljs-comment">// Synchronous task...</span>
    }
    b.toc();
    b.end();
});
</code></pre><p>To trigger an action when a harness finishes running all benchmarks, provide a callback <code>function</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> harness = bench.createHarness( onFinish );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onFinish</span>(<span class="hljs-params"></span>) </span>{
    harness.close();
}

harness( <span class="hljs-string">'beep'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">benchmark</span>(<span class="hljs-params"> b </span>) </span>{
    <span class="hljs-keyword">var</span> i;
    b.tic();
    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &#x3C; b.iterations; i++ ) {
        <span class="hljs-comment">// Synchronous task...</span>
    }
    b.toc();
    b.end();
});
</code></pre><p>The method accepts the following <code>options</code>:</p><ul><li><strong>autoclose</strong>: <code>boolean</code> indicating whether to automatically close a harness after running all benchmarks.</li></ul><p>By default, a <code>harness</code> does <strong>not</strong> automatically close. To automatically close a harness once a harness finishes running all benchmarks, set the <code>autoclose</code> option to <code>true</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> harness = bench.createHarness({
    <span class="hljs-string">'autoclose'</span>: <span class="hljs-literal">true</span>
});

harness( <span class="hljs-string">'beep'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">benchmark</span>(<span class="hljs-params"> b </span>) </span>{
    <span class="hljs-keyword">var</span> i;
    b.tic();
    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &#x3C; b.iterations; i++ ) {
        <span class="hljs-comment">// Synchronous task...</span>
    }
    b.toc();
    b.end();
});
</code></pre><hr><h3 id="harness">Harness</h3><p>A <code>harness</code> has the following properties and methods...</p><p><a name="harness-createstream"></a></p><h4 id="harnesscreatestream-options-">harness.createStream( [options] )</h4><p>Returns a results <a href="https://nodejs.org/api/stream.html">stream</a>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> stdout = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/streams/node/stdout'</span> );

<span class="hljs-keyword">var</span> harness = bench.createHarness();
<span class="hljs-keyword">var</span> stream = harness.createStream();

<span class="hljs-comment">// Direct all results to `stdout`:</span>
stream.pipe( stdout );

<span class="hljs-keyword">var</span> opts = {
    <span class="hljs-string">'iterations'</span>: <span class="hljs-number">1</span>,
    <span class="hljs-string">'repeats'</span>: <span class="hljs-number">1</span>
};

harness( <span class="hljs-string">'beep'</span>, opts, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">benchmark</span>(<span class="hljs-params"> b </span>) </span>{
    <span class="hljs-keyword">var</span> i;
    b.tic();
    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &#x3C; b.iterations; i++ ) {
        b.equal( <span class="hljs-string">'beep'</span>, <span class="hljs-string">'beep'</span>, <span class="hljs-string">'should be equal'</span> );
    }
    b.toc();
    b.end();
});
</code></pre><pre><code class="no-highlight language-text">TAP version 13
# beep
ok 1 should be equal
  ---
  iterations: 1
  elapsed: 0.00166768
  rate: 599.6354216636286
  ...
#
1..1
# total 1
# pass  1
#
# ok
</code></pre><p>The method accepts the same <code>options</code> as <a href="/docs/api/latest/@stdlib/streams/node/transform">@stdlib/streams/node/transform</a>.</p><p><strong>Note</strong>: benchmarks will <strong>not</strong> run until a destination stream has been created.</p><p><a name="harness-close"></a></p><h4 id="harnessclose">harness.close()</h4><p>Closes a benchmark harness. Any pending benchmarks are cleared from the harness stack.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> stdout = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/streams/node/stdout'</span> );

<span class="hljs-keyword">var</span> harness = bench.createHarness();

<span class="hljs-keyword">var</span> stream = harness.createStream();
stream.pipe( stdout );

<span class="hljs-keyword">var</span> opts = {
    <span class="hljs-string">'iterations'</span>: <span class="hljs-number">5</span>,
    <span class="hljs-string">'repeats'</span>: <span class="hljs-number">5</span>
};

harness( <span class="hljs-string">'early close'</span>, opts, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">benchmark</span>(<span class="hljs-params"> b </span>) </span>{
    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;
    b.tic();
    <span class="hljs-built_in">setTimeout</span>( next, <span class="hljs-number">0</span> );
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span>(<span class="hljs-params"></span>) </span>{
        i += <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> ( i &#x3C;= b.iterations ) {
            b.ok( <span class="hljs-literal">true</span>, <span class="hljs-string">'should be truthy'</span> );
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">setTimeout</span>( next, <span class="hljs-number">10</span> );
        }
        b.toc();
        b.end();
    }
});

<span class="hljs-comment">// Early close:</span>
<span class="hljs-built_in">setTimeout</span>( onTimeout, <span class="hljs-number">50</span> );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onTimeout</span>(<span class="hljs-params"></span>) </span>{
    harness.close();
}
</code></pre><pre><code class="no-highlight language-text">TAP version 13
# early close
ok 1 should be truthy
ok 2 should be truthy
# WARNING: harness closed before completion.
ok 3 should be truthy
ok 4 should be truthy
ok 5 should be truthy
  ---
  iterations: 5
  elapsed: 0.05940291
  rate: 84.17096064822414
  ...
</code></pre><p><strong>Warning</strong>: a running benchmark may finish <strong>after</strong> closing a harness.</p><p><a name="harness-exit"></a></p><h4 id="harnessexit">harness.exit()</h4><p>Forcefully exits a benchmark harness. All pending benchmarks will generate <strong>failing</strong> assertions.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> stdout = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/streams/node/stdout'</span> );

<span class="hljs-keyword">var</span> harness = bench.createHarness();

<span class="hljs-keyword">var</span> stream = harness.createStream();
stream.pipe( stdout );

<span class="hljs-keyword">var</span> opts = {
    <span class="hljs-string">'iterations'</span>: <span class="hljs-number">5</span>
};

harness( <span class="hljs-string">'force exit'</span>, opts, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">benchmark</span>(<span class="hljs-params"> b </span>) </span>{
    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;
    b.tic();
    <span class="hljs-keyword">return</span> next();
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span>(<span class="hljs-params"></span>) </span>{
        i += <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> ( i &#x3C;= b.iterations ) {
            b.ok( <span class="hljs-literal">true</span>, <span class="hljs-string">'should be truthy'</span> );
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">setTimeout</span>( next, <span class="hljs-number">10</span> );
        }
        b.toc();
        b.end();
    }
});

<span class="hljs-comment">// Forcefully exit:</span>
<span class="hljs-built_in">setTimeout</span>( onTimeout, <span class="hljs-number">20</span> );

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onTimeout</span>(<span class="hljs-params"></span>) </span>{
    harness.exit();
}
</code></pre><pre><code class="no-highlight language-text">TAP version 13
# force exit
ok 1 should be truthy
not ok 2 benchmark exited without ending
  ---
  operator: fail
  TODO: include stack
  ...
not ok 3 benchmark exited without ending
  ---
  operator: fail
  TODO: include stack
  ...
ok 4 should be truthy
ok 5 should be truthy
ok 6 should be truthy
ok 7 should be truthy
  ---
  iterations: 5
  elapsed: 0.061504862
  rate: 81.29438612511642
  ...
</code></pre><p><strong>Warning</strong>: a running benchmark may finish <strong>after</strong> exiting a harness.</p><p><a name="harness-exitcode"></a></p><h4 id="harnessexitcode">harness.exitCode</h4><p><strong>Read-only</strong> property whose value is the harness exit code. If all benchmarks run successfully (i.e., no failing assertions), the exit code is <code>0</code>; otherwise, the exit code is <code>1</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> harness = bench.createHarness();

<span class="hljs-comment">// Benchmarks only start running when results have a destination:</span>
<span class="hljs-keyword">var</span> stream = harness.createStream();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onFinish</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log( harness.exitCode );
    <span class="hljs-comment">// => 1</span>
}

<span class="hljs-keyword">var</span> opts = {
    <span class="hljs-string">'iterations'</span>: <span class="hljs-number">1</span>,
    <span class="hljs-string">'repeats'</span>: <span class="hljs-number">1</span>
};

harness( <span class="hljs-string">'exit code'</span>, opts, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">benchmark</span>(<span class="hljs-params"> b </span>) </span>{
    <span class="hljs-keyword">var</span> i;
    b.tic();
    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &#x3C; b.iterations; i++ ) {
        b.fail( <span class="hljs-string">'failing assertion'</span> );
    }
    b.toc();
    b.end();
});
</code></pre><hr><h3 id="benchmark-1">Benchmark</h3><p>A <code>Benchmark</code> instance has the following properties and methods...</p><p><a name="benchmark-name"></a></p><h4 id="bname">b.name</h4><p><strong>Read-only</strong> property whose value is the benchmark <code>name</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> str = b.name;
<span class="hljs-comment">// returns &#x3C;string></span>
</code></pre><p><a name="benchmark-iterations"></a></p><h4 id="biterations">b.iterations</h4><p><strong>Read-only</strong> property whose value is the number of iterations.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> iter = b.iterations;
<span class="hljs-comment">// returns &#x3C;number></span>
</code></pre><p><a name="benchmark-tic"></a></p><h4 id="btic">b.tic()</h4><p>Starts a benchmark timer. In order to benchmark code, this method <strong>must always</strong> be called within a <code>benchmark</code> function.</p><pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">benchmark</span>(<span class="hljs-params"> b </span>) </span>{
    <span class="hljs-keyword">var</span> x;
    <span class="hljs-keyword">var</span> i;

    <span class="hljs-comment">// Start a timer:</span>
    b.tic();

    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &#x3C; b.iterations; i++ ) {
        x = <span class="hljs-built_in">Math</span>.sin( <span class="hljs-built_in">Math</span>.random() );
        <span class="hljs-keyword">if</span> ( x !== x ) {
            b.fail( <span class="hljs-string">'should not return NaN'</span> );
        }
    }
    b.toc();
    <span class="hljs-keyword">if</span> ( x !== x ) {
        b.fail( <span class="hljs-string">'should not return NaN'</span> );
    }
    b.end();
}
</code></pre><p><a name="benchmark-toc"></a></p><h4 id="btoc">b.toc()</h4><p>Stops a benchmark timer. In order to benchmark code, this method <strong>must always</strong> be called within a <code>benchmark</code> function.</p><pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">benchmark</span>(<span class="hljs-params"> b </span>) </span>{
    <span class="hljs-keyword">var</span> x;
    <span class="hljs-keyword">var</span> i;

    b.tic();
    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &#x3C; b.iterations; i++ ) {
        x = <span class="hljs-built_in">Math</span>.sin( <span class="hljs-built_in">Math</span>.random() );
        <span class="hljs-keyword">if</span> ( x !== x ) {
            b.fail( <span class="hljs-string">'should not return NaN'</span> );
        }
    }
    <span class="hljs-comment">// Stop a timer:</span>
    b.toc();

    <span class="hljs-keyword">if</span> ( x !== x ) {
        b.fail( <span class="hljs-string">'should not return NaN'</span> );
    }
    b.end();
}
</code></pre><p><a name="benchmark-end"></a></p><h4 id="bend">b.end()</h4><p>Explicitly ends a benchmark. In order to benchmark code, this method <strong>must always</strong> be called within a <code>benchmark</code> function.</p><pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">benchmark</span>(<span class="hljs-params"> b </span>) </span>{
    <span class="hljs-keyword">var</span> x;
    <span class="hljs-keyword">var</span> i;

    b.tic();
    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &#x3C; b.iterations; i++ ) {
        x = <span class="hljs-built_in">Math</span>.sin( <span class="hljs-built_in">Math</span>.random() );
        <span class="hljs-keyword">if</span> ( x !== x ) {
            b.fail( <span class="hljs-string">'should not return NaN'</span> );
        }
    }
    b.toc();

    <span class="hljs-keyword">if</span> ( x !== x ) {
        b.fail( <span class="hljs-string">'should not return NaN'</span> );
    }

    <span class="hljs-comment">// Explicitly end the benchmark:</span>
    b.end();
}
</code></pre><p><strong>Warning</strong>: no assertions should follow a call to <code>b.end()</code>. Including assertions after <code>b.end()</code> may result in interleaved <a href="https://testanything.org/tap-version-13-specification.html">TAP</a> output or an output stream closing before a benchmark executes pending assertions.</p><p><a name="benchmark-comment"></a></p><h4 id="bcomment-msg-">b.comment( msg )</h4><p>Writes a message without breaking <a href="https://testanything.org/tap-version-13-specification.html">TAP</a> output.</p><pre><code class="hljs language-javascript">b.comment( <span class="hljs-string">'This is a comment.'</span> );
</code></pre><pre><code class="no-highlight language-text"># This is a comment.
</code></pre><p>To prevent confusing results parsers, <strong>avoid</strong> using comments. Comments are frequently used for demarcating the beginning of a new benchmark run and/or providing diagnostic information. Both of the aforementioned use cases typically fall under the domain of the harness, not the user.</p><p><a name="benchmark-skip"></a></p><h4 id="bskip-value-msg-">b.skip( value, msg )</h4><p>Generates an assertion which will be skipped.</p><pre><code class="hljs language-javascript">b.skip( <span class="hljs-literal">false</span>, <span class="hljs-string">'This is skipped.'</span> );
b.skip( <span class="hljs-literal">true</span>, <span class="hljs-string">'This is skipped.'</span> );
</code></pre><pre><code class="no-highlight language-text">ok 1 This is skipped. # SKIP
ok 2 This is skipped. # SKIP
</code></pre><p><a name="benchmark-todo"></a></p><h4 id="btodo-value-msg-">b.todo( value, msg )</h4><p>Generates an assertion which should be implemented.</p><pre><code class="hljs language-javascript">b.todo( <span class="hljs-literal">false</span>, <span class="hljs-string">'This is a todo.'</span> );
b.todo( <span class="hljs-literal">true</span>, <span class="hljs-string">'This is a todo.'</span> );
</code></pre><pre><code class="no-highlight language-text">not ok 3 This is a todo. # TODO
  ---
  operator: todo
  TODO: include stack
  ...
ok 4 This is a todo. # TODO
</code></pre><p>While <code>b.todo()</code> assertions typically fail, they do <strong>not</strong> contribute to the failed assertion count. If a benchmark includes <code>b.todo()</code> assertions and no other failing assertions, the benchmark is considered successful.</p><p><a name="benchmark-fail"></a></p><h4 id="bfail-msg-">b.fail( msg )</h4><p>Generates a failing assertion.</p><pre><code class="hljs language-javascript">b.fail( <span class="hljs-string">'This is a failing assertion.'</span> );
</code></pre><pre><code class="no-highlight language-text">not ok 5 This is a failing assertion.
  ---
  operator: fail
  TODO: include stack
  ... 
</code></pre><p><a name="benchmark-pass"></a></p><h4 id="bpass-msg-">b.pass( msg )</h4><p>Generates a passing assertion.</p><pre><code class="hljs language-javascript">b.pass( <span class="hljs-string">'This is a passing assertion.'</span> );
</code></pre><pre><code class="no-highlight language-text">ok 6 This is a passing assertion.
</code></pre><p><a name="benchmark-ok"></a></p><h4 id="bok-value-msg-">b.ok( value[, msg] )</h4><p>Asserts that a <code>value</code> is truthy.</p><pre><code class="hljs language-javascript">b.ok( [] );
</code></pre><pre><code class="no-highlight language-text">ok 7 should be truthy
</code></pre><p>To override the default message, provide a <code>msg</code> argument.</p><pre><code class="hljs language-javascript">b.ok( <span class="hljs-literal">true</span>, <span class="hljs-string">'This asserts a value is truthy.'</span> );
b.ok( <span class="hljs-literal">false</span>, <span class="hljs-string">'This asserts a value is truthy.'</span> );
</code></pre><pre><code class="no-highlight language-text">ok 8 This asserts a value is truthy.
not ok 9 This asserts a value is truthy.
  ---
  operator: ok
  TODO: include stack
  ...
</code></pre><p><a name="benchmark-notok"></a></p><h4 id="bnotok-value-msg-">b.notOk( value[, msg] )</h4><p>Asserts that a <code>value</code> is falsy.</p><pre><code class="hljs language-javascript">b.notOk( <span class="hljs-literal">null</span> );
</code></pre><pre><code class="no-highlight language-text">ok 10 should be falsy
</code></pre><p>To override the default message, provide a <code>msg</code> argument.</p><pre><code class="hljs language-javascript">b.notOk( <span class="hljs-literal">false</span>, <span class="hljs-string">'This asserts a value is falsy.'</span> );
b.notOk( <span class="hljs-literal">true</span>, <span class="hljs-string">'This asserts a value is falsy.'</span> );
</code></pre><pre><code class="no-highlight language-text">ok 11 This asserts a value is falsy.
not ok 12 This asserts a value is falsy.
  ---
  operator: notOk
  TODO: include stack
  ...
</code></pre><p><a name="benchmark-equal"></a></p><h4 id="bequal-actual-expected-msg-">b.equal( actual, expected[, msg] )</h4><p>Asserts that <code>actual</code> is <strong>strictly</strong> equal to <code>expected</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> expected = [];
<span class="hljs-keyword">var</span> actual = expected;

b.equal( actual, expected );
</code></pre><pre><code class="no-highlight language-text">ok 13 should be equal
</code></pre><p>To override the default message, provide a <code>msg</code> argument.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> expected = [];
<span class="hljs-keyword">var</span> actual = expected;

b.equal( actual, expected, <span class="hljs-string">'This asserts two values are strictly equal.'</span> );
b.equal( <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-string">'This asserts two values are strictly equal.'</span> );
</code></pre><pre><code class="no-highlight language-text">ok 14 This asserts two values are strictly equal.
not ok 15 This asserts two values are strictly equal.
  ---
  operator: equal
  TODO: include stack
  ...
</code></pre><p><a name="benchmark-notequal"></a></p><h4 id="bnotequal-actual-expected-msg-">b.notEqual( actual, expected[, msg] )</h4><p>Asserts that <code>actual</code> is not <strong>strictly</strong> equal to <code>expected</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> expected = [];
<span class="hljs-keyword">var</span> actual = [];

b.notEqual( actual, expected );
</code></pre><pre><code class="no-highlight language-text">ok 16 should not be equal
</code></pre><p>To override the default message, provide a <code>msg</code> argument.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> expected = [];
<span class="hljs-keyword">var</span> actual = [];

b.notEqual( <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-string">'This asserts two values are not equal.'</span> );
b.notEqual( actual, expected, <span class="hljs-string">'This asserts two values are not equal.'</span> );
</code></pre><pre><code class="no-highlight language-text">ok 17 This asserts two values are not equal.
not ok 18 This asserts two values are not equal.
  ---
  operator: notEqual
  TODO: include stack
  ...
</code></pre><p><a name="benchmark-deepequal"></a></p><h4 id="bdeepequal-actual-expected-msg-">b.deepEqual( actual, expected[, msg] )</h4><p>Asserts that <code>actual</code> is <strong>deeply</strong> equal to <code>expected</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> expected = {
    <span class="hljs-string">'a'</span>: <span class="hljs-string">'b'</span>
};
<span class="hljs-keyword">var</span> actual = {
    <span class="hljs-string">'a'</span>: <span class="hljs-string">'b'</span>
};

b.deepEqual( actual, expected );
</code></pre><pre><code class="no-highlight language-text">ok 19 should be deeply equal
</code></pre><p>To override the default message, provide a <code>msg</code> argument.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> expected = {
    <span class="hljs-string">'a'</span>: <span class="hljs-string">'b'</span>
};
<span class="hljs-keyword">var</span> actual = {
    <span class="hljs-string">'a'</span>: <span class="hljs-string">'b'</span>
};

b.deepEqual( actual, expected, <span class="hljs-string">'This asserts two values are deeply equal.'</span> );

actual.a = <span class="hljs-string">'c'</span>;
b.deepEqual( actual, expected, <span class="hljs-string">'This asserts two values are deeply equal.'</span> );
</code></pre><pre><code class="no-highlight language-text">TODO
</code></pre><p><a name="benchmark-notdeepequal"></a></p><h4 id="bnotdeepequal-actual-expected-msg-">b.notDeepEqual( actual, expected[, msg] )</h4><p>Asserts that <code>actual</code> is not <strong>deeply</strong> equal to <code>expected</code>.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> expected = {
    <span class="hljs-string">'a'</span>: <span class="hljs-string">'b'</span>
};
<span class="hljs-keyword">var</span> actual = {
    <span class="hljs-string">'a'</span>: <span class="hljs-string">'c'</span>
};

b.notDeepEqual( actual, expected );
</code></pre><pre><code class="no-highlight language-text">ok 22 should not be deeply equal
</code></pre><p>To override the default message, provide a <code>msg</code> argument.</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> expected = {
    <span class="hljs-string">'a'</span>: <span class="hljs-string">'b'</span>
};
<span class="hljs-keyword">var</span> actual = {
    <span class="hljs-string">'a'</span>: <span class="hljs-string">'c'</span>
};

b.notDeepEqual( actual, expected, <span class="hljs-string">'This asserts two values are not deeply equal.'</span> );

actual.a = <span class="hljs-string">'b'</span>;
b.notDeepEqual( actual, expected, <span class="hljs-string">'This asserts two values are not deeply equal.'</span> );
</code></pre><pre><code class="no-highlight language-text">TODO
</code></pre></section><hr><section class="notes"><h2 id="notes">Notes</h2><ul><li>All benchmark functions execute <strong>serially</strong> in separate turns of the event loop.</li><li>All benchmark functions should be added during the <strong>same</strong> turn of the event loop. Otherwise, you will likely encounter race conditions where a benchmark executes and finishes causing a harness to close <strong>before</strong> subsequent benchmarks register.</li><li>Similarly, create results streams <strong>before</strong> adding benchmarks to the harness. Otherwise, you will likely miss benchmark results.</li><li>If a harness is invoked without providing a <code>benchmark</code> function, the benchmark is considered a <code>todo</code> and <code>opts.repeat</code> is ignored.</li><li>All benchmarks are pretested. If a benchmark generates failing assertions or fails to call <code>b.tic()</code> and/or <code>b.toc()</code> during pretests (even if due to an intermittent failure), a benchmark is <strong>only</strong> run once (i.e., <code>options.repeats</code> is ignored). Similarly, if <code>options.iterations</code> is <code>null</code> and a benchmark fails during iteration number determination, a benchmark is <strong>only</strong> run once and for one iteration. Accordingly, if a benchmark does not run an expected number of repetitions and/or iterations, this behavior is likely attributable to a benchmark failure during pretesting.</li><li>All benchmarks must have a <code>name</code>. If a <code>name</code> is not provided, the harness will throw an <code>Error</code>.</li><li>While not required, all benchmarks should have a <strong>unique</strong> <code>name</code>. Unique names ensure easier identification and assignment of benchmark results.</li><li>Uncaught exceptions in benchmark functions are <strong>not</strong> intercepted and will cause the harness to error.</li><li>If any one of <code>b.tic()</code>, <code>b.toc()</code>, or <code>b.end()</code> is called more than once within a benchmark, the benchmark will <strong>fail</strong>.</li><li><strong>Always</strong> verify results. Doing so prevents the compiler from performing dead code elimination and other optimization techniques, which would render timing results meaningless.</li><li>While many benchmark frameworks calculate various statistics over raw timing results (e.g., mean and standard deviation), do <strong>not</strong> do this. Instead, consider the fastest time an approximate lower bound for how fast an environment can execute benchmark code. Slower times are more likely attributable to other processes interfering with timing accuracy rather than attributable to variability in JavaScript's speed. In which case, the minimum time is most likely the only result of interest. When considering all raw timing results, apply common sense rather than statistics.</li></ul><h3 id="tap">TAP</h3><ul><li><p>Results are output in accordance with the Test Anything Protocol (<a href="https://testanything.org/tap-version-13-specification.html">TAP</a>) version <a href="https://testanything.org/tap-version-13-specification.html">13</a>.</p></li><li><p>Example <a href="https://testanything.org/tap-version-13-specification.html">TAP</a> output:</p><pre><code class="no-highlight language-text">TAP version 13
# Math.hypot
  ---
  iterations: 1000000
  elapsed: 0.457849215
  rate: 2184125.181911691
  ...
ok 1 benchmark finished
# Math.hypot
  ---
  iterations: 1000000
  elapsed: 0.454676639
  rate: 2199365.250432407
  ...
ok 2 benchmark finished
# Math.hypot
  ---
  iterations: 1000000
  elapsed: 0.472378014
  rate: 2116948.652059831
  ...
ok 3 benchmark finished
# hypot
  ---
  iterations: 1000000
  elapsed: 0.13120811
  rate: 7621480.105155086
  ...
ok 4 benchmark finished
# hypot
  ---
  iterations: 1000000
  elapsed: 0.129308984
  rate: 7733414.717727579
  ...
ok 5 benchmark finished
# hypot
  ---
  iterations: 1000000
  elapsed: 0.12404053
  rate: 8061881.064197323
  ...
ok 6 benchmark finished
#
1..6
# total 6
# pass  6
#
# ok
</code></pre></li><li><p>For each failing assertion, the harness outputs diagnostic information as <a href="https://yaml.org/">YAML</a> blocks.</p><pre><code class="no-highlight language-text">TODO
</code></pre></li><li><p>Timing results are output as <a href="https://yaml.org/">YAML</a> blocks. The fields are as follows:</p><ul><li><strong>iterations</strong>: number of iterations.</li><li><strong>elapsed</strong>: total elapsed time beginning with <code>b.tic()</code> and ending with <code>b.toc()</code> (in seconds).</li><li><strong>rate</strong>: number of operations per second.</li></ul></li></ul></section><hr><section class="examples"><h2 id="examples">Examples</h2><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> randu = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/random/base/randu'</span> );
<span class="hljs-keyword">var</span> isnan = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/math/base/assert/is-nan'</span> );
<span class="hljs-keyword">var</span> sin = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/math/base/special/sin'</span> );
<span class="hljs-keyword">var</span> bench = <span class="hljs-built_in">require</span>( <span class="hljs-string">'@stdlib/bench/harness'</span> );

<span class="hljs-keyword">var</span> opts = {
    <span class="hljs-string">'iterations'</span>: <span class="hljs-number">1e6</span>,
    <span class="hljs-string">'repeats'</span>: <span class="hljs-number">3</span>
};

bench( <span class="hljs-string">'Math.sin'</span>, opts, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">benchmark</span>(<span class="hljs-params"> b </span>) </span>{
    <span class="hljs-keyword">var</span> x;
    <span class="hljs-keyword">var</span> y;
    <span class="hljs-keyword">var</span> i;

    b.tic();
    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &#x3C; b.iterations; i++ ) {
        x = (randu()*<span class="hljs-number">100.0</span>) - <span class="hljs-number">50.0</span>;
        y = <span class="hljs-built_in">Math</span>.sin( x );
        <span class="hljs-keyword">if</span> ( y &#x3C; -<span class="hljs-number">1.0</span> || y > <span class="hljs-number">1.0</span> ) {
            b.fail( <span class="hljs-string">'something went wrong!'</span> );
        }
    }
    b.toc();

    <span class="hljs-keyword">if</span> ( isnan( y ) ) {
        b.fail( <span class="hljs-string">'something went wrong!'</span> );
    }
    b.pass( <span class="hljs-string">'benchmark finished'</span> );
    b.end();
});

bench( <span class="hljs-string">'sin'</span>, opts, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">benchmark</span>(<span class="hljs-params"> b </span>) </span>{
    <span class="hljs-keyword">var</span> x;
    <span class="hljs-keyword">var</span> y;
    <span class="hljs-keyword">var</span> i;

    b.tic();
    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &#x3C; b.iterations; i++ ) {
        x = (randu()*<span class="hljs-number">100.0</span>) - <span class="hljs-number">50.0</span>;
        y = sin( x );
        <span class="hljs-keyword">if</span> ( y &#x3C; -<span class="hljs-number">1.0</span> || y > <span class="hljs-number">1.0</span> ) {
            b.fail( <span class="hljs-string">'something went wrong!'</span> );
        }
    }
    b.toc();

    <span class="hljs-keyword">if</span> ( isnan( y ) ) {
        b.fail( <span class="hljs-string">'something went wrong!'</span> );
    }
    b.pass( <span class="hljs-string">'benchmark finished'</span> );
    b.end();
});
</code></pre></section><hr><section class="cli"><h2 id="cli">CLI</h2><section class="usage"><h3 id="usage-1">Usage</h3><pre><code class="no-highlight language-text">Usage: bench [options] &#x3C;glob> ...

Options:

  -h,    --help                Print this message.
  -V,    --version             Print the package version.
  -r,    --require module      Load module before running benchmarks.
</code></pre></section><section class="notes"><h3 id="notes-1">Notes</h3><ul><li><p>Running benchmark files does <strong>not</strong> require using the command-line interface. For example, to run a single file containing benchmarks,</p><pre><code class="hljs language-bash">$ node /path/to/benchmark.js
</code></pre></li><li><p>To load one or more modules <strong>before</strong> running benchmarks, set the <code>-r</code> flag one or more times. For example,</p><pre><code class="hljs language-bash">$ bench -r foo -r bar <span class="hljs-string">'benchmark/*.js'</span>
</code></pre><p>the modules <code>foo</code> and <code>bar</code> will both be loaded <strong>before</strong> any benchmarks matching the glob <code>benchmark/*.js</code>. The <code>-r</code> flag behaves exactly like <code>require</code>, and modules are resolved relative to the current working directory. To load local modules, use relative paths.</p><pre><code class="hljs language-bash">$ bench -r ./foo/bar.js -r ./beep/boop/bap <span class="hljs-string">'benchmark/*.js'</span>
</code></pre><p>Note that <code>-r</code> modules are loaded <strong>before</strong> running benchmarks regardless of order. Hence,</p><pre><code class="hljs language-bash">$ bench -r foo -r bar <span class="hljs-string">'benchmark/*.js'</span>
</code></pre><p>and</p><pre><code class="hljs language-bash">$ bench -r foo <span class="hljs-string">'benchmark/*.js'</span> -r bar
</code></pre><p>behave the same.</p><p>Depending on the preloaded module, a module may support parameterization via environment variables, command-line options, and/or configuration files.</p></li><li><p>To perform shell expansion on systems supporting globbing, do not quote provided globs.</p><pre><code class="hljs language-bash">$ bench benchmark/*.js
</code></pre><p>Beware, however, that globbing via shell expansion may result in shell argument lists which exceed length limits. To prevent shell expansion, wrap globs in quotes.</p><pre><code class="hljs language-bash">$ bench <span class="hljs-string">'benchmark/*.js'</span>
$ bench <span class="hljs-string">"benchmark/*.js"</span>
</code></pre></li></ul></section><section class="examples"><h3 id="examples-1">Examples</h3><pre><code class="hljs language-bash">$ bench ./examples/index.js
</code></pre><p>will generate <a href="https://testanything.org/tap-version-13-specification.html">TAP</a> output similar to the following</p><pre><code class="no-highlight language-text">TAP version 13
# Math.sin
  ---
  iterations: 1000000
  elapsed: 0.107631765
  rate: 9290937.484858675
  ...
ok 1 benchmark finished
# Math.sin
  ---
  iterations: 1000000
  elapsed: 0.100319363
  rate: 9968165.368035682
  ...
ok 2 benchmark finished
# Math.sin
  ---
  iterations: 1000000
  elapsed: 0.095116262
  rate: 10513449.31952856
  ...
ok 3 benchmark finished
# sin
  ---
  iterations: 1000000
  elapsed: 0.173696195
  rate: 5757178.503536016
  ...
ok 4 benchmark finished
# sin
  ---
  iterations: 1000000
  elapsed: 0.158544701
  rate: 6307369.42762912
  ...
ok 5 benchmark finished
# sin
  ---
  iterations: 1000000
  elapsed: 0.157709895
  rate: 6340756.234730865
  ...
ok 6 benchmark finished
#
1..6
# total 6
# pass  6
#
# ok
</code></pre></section></section><hr><section class="references"><h2 id="references">References</h2><ul><li>Chen, Jiahao, and Jarrett Revels. 2016. "Robust benchmarking in noisy environments." <em>CoRR</em> abs/1608.04295 (August). <a href="http://arxiv.org/abs/1608.04295">http://arxiv.org/abs/1608.04295</a>.</li></ul></section><section class="related"></section><section class="links"></section>